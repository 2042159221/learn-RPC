# Ming RPC Framework æœåŠ¡æ³¨å†Œä¿¡æ¯ç¼“å­˜æ›´æ–°ä¸ä¸€è‡´æ€§ä¿éšœè¯¦è§£

## ğŸ“– æ¦‚è¿°

åœ¨åˆ†å¸ƒå¼RPCæ¡†æ¶ä¸­ï¼ŒæœåŠ¡æ¶ˆè´¹è€…é€šå¸¸ä¼šå°†ä»æ³¨å†Œä¸­å¿ƒè·å–çš„æœåŠ¡æä¾›è€…ä¿¡æ¯ç¼“å­˜åœ¨æœ¬åœ°ï¼Œä»¥æé«˜æ€§èƒ½å’Œå¯ç”¨æ€§ã€‚Ming RPC Frameworké€šè¿‡å¤šçº§ç¼“å­˜æœºåˆ¶å’Œå®æ—¶æ›´æ–°ç­–ç•¥ï¼Œç¡®ä¿äº†ç¼“å­˜æ•°æ®çš„ä¸€è‡´æ€§å’Œç³»ç»Ÿçš„é«˜å¯ç”¨æ€§ã€‚

### ğŸ¯ æ ¸å¿ƒé—®é¢˜
> å¦‚ä½•æ›´æ–°æœåŠ¡æ³¨å†Œä¿¡æ¯ç¼“å­˜ï¼Ÿæ€ä¹ˆä¿è¯ç¼“å­˜çš„æ•°æ®ä¸€è‡´æ€§ï¼Ÿ

### ğŸ’¡ è®¾è®¡ç›®æ ‡
1. **é«˜æ€§èƒ½**: å‡å°‘å¯¹æ³¨å†Œä¸­å¿ƒçš„é¢‘ç¹è®¿é—®ï¼Œæå‡æœåŠ¡å‘ç°æ€§èƒ½
2. **é«˜å¯ç”¨**: åœ¨æ³¨å†Œä¸­å¿ƒä¸å¯ç”¨æ—¶ï¼Œä»èƒ½æä¾›æœåŠ¡å‘ç°èƒ½åŠ›
3. **ä¸€è‡´æ€§**: ä¿è¯ç¼“å­˜æ•°æ®ä¸æ³¨å†Œä¸­å¿ƒæ•°æ®çš„æœ€ç»ˆä¸€è‡´æ€§
4. **å®æ—¶æ€§**: å¿«é€Ÿæ„ŸçŸ¥æœåŠ¡å®ä¾‹çš„ä¸Šä¸‹çº¿å˜åŒ–

### ğŸ—ï¸ ç¼“å­˜æ¶æ„è®¾è®¡
```mermaid
graph TD
    A[æœåŠ¡æ¶ˆè´¹è€…] --> B[å¤šçº§ç¼“å­˜ç³»ç»Ÿ]
    B --> C[å†…å­˜ç¼“å­˜]
    B --> D[Watchæœºåˆ¶]
    B --> E[å®šæ—¶åˆ·æ–°]

    C --> F[RegistryServiceMultiCache]
    D --> G[Etcd Watch]
    E --> H[å®šæ—¶ä»»åŠ¡]

    F --> I[ConcurrentHashMap]
    G --> J[å®æ—¶é€šçŸ¥]
    H --> K[æ‰¹é‡æ›´æ–°]

    style B fill:#e1f5fe
    style F fill:#f3e5f5
```

## ğŸ”§ Ming RPC Frameworkç¼“å­˜å®ç°

### 1. å¤šçº§ç¼“å­˜æ¶æ„

#### RegistryServiceMultiCacheæ ¸å¿ƒå®ç°
**æ–‡ä»¶è·¯å¾„**: `rpc-core/src/main/java/com/ming/rpc/registry/RegistryServiceMultiCache.java`

```java
/**
 * æ³¨å†Œä¸­å¿ƒæœåŠ¡æœ¬åœ°ç¼“å­˜ï¼ˆæ”¯æŒå¤šä¸ªæœåŠ¡é”®åç¼“å­˜ï¼‰
 */
public class RegistryServiceMultiCache {
    /**
     * æœåŠ¡ç¼“å­˜ - æ”¯æŒå¤šæœåŠ¡å¹¶å‘ç¼“å­˜
     * Key: æœåŠ¡é”®å (å¦‚ "UserService:1.0")
     * Value: æœåŠ¡å®ä¾‹åˆ—è¡¨
     */
    Map<String, List<ServiceMetaInfo>> serviceCache = new ConcurrentHashMap<>();

    /**
     * å†™ç¼“å­˜
     * @param serviceKey æœåŠ¡é”®å
     * @param newServiceCache æ–°æœåŠ¡ç¼“å­˜
     */
    void writeCache(String serviceKey, List<ServiceMetaInfo> newServiceCache) {
        this.serviceCache.put(serviceKey, newServiceCache);
    }

    /**
     * è¯»ç¼“å­˜
     * @param serviceKey æœåŠ¡é”®å
     * @return ç¼“å­˜çš„æœåŠ¡åˆ—è¡¨ï¼Œæœªæ‰¾åˆ°è¿”å›null
     */
    List<ServiceMetaInfo> readCache(String serviceKey) {
        return this.serviceCache.get(serviceKey);
    }

    /**
     * æ¸…ç©ºæŒ‡å®šæœåŠ¡ç¼“å­˜
     * @param serviceKey æœåŠ¡é”®å
     */
    void clearCache(String serviceKey) {
        this.serviceCache.remove(serviceKey);
    }
}
```

### 2. ç¼“å­˜æ›´æ–°ç­–ç•¥

#### ç­–ç•¥ä¸€ï¼šä¼˜å…ˆç¼“å­˜è¯»å–
```mermaid
sequenceDiagram
    participant Consumer as æœåŠ¡æ¶ˆè´¹è€…
    participant Cache as æœ¬åœ°ç¼“å­˜
    participant Registry as æ³¨å†Œä¸­å¿ƒ

    Consumer->>Cache: æŸ¥è¯¢æœåŠ¡å®ä¾‹
    Cache-->>Consumer: è¿”å›ç¼“å­˜æ•°æ®(å¦‚æœå­˜åœ¨)

    Note over Consumer: ç¼“å­˜æœªå‘½ä¸­
    Consumer->>Registry: æŸ¥è¯¢æœåŠ¡å®ä¾‹
    Registry-->>Consumer: è¿”å›æœ€æ–°æ•°æ®
    Consumer->>Cache: å†™å…¥ç¼“å­˜
    Consumer->>Registry: å»ºç«‹Watchç›‘å¬
```

#### EtcdRegistryç¼“å­˜å®ç°
```java
@Override
public List<ServiceMetaInfo> serviceDiscovery(String serviceKey) {
    // ä¼˜å…ˆä»ç¼“å­˜è·å–æœåŠ¡
    List<ServiceMetaInfo> cachedServiceMetaInfoList =
        registryServiceMultiCache.readCache(serviceKey);
    if(cachedServiceMetaInfoList != null){
        return cachedServiceMetaInfoList;
    }

    // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ³¨å†Œä¸­å¿ƒæŸ¥è¯¢
    String searchPrefix = ETCD_ROOT_PATH + serviceKey + "/";

    try {
        // å‰ç¼€æœç´¢
        GetOption getOption = GetOption.builder().isPrefix(true).build();
        List<KeyValue> keyValues = kvClient.get(
            ByteSequence.from(searchPrefix, StandardCharsets.UTF_8),
            getOption
        ).get().getKvs();

        // è§£ææœåŠ¡ä¿¡æ¯
        List<ServiceMetaInfo> serviceMetaInfoList = keyValues.stream()
        .map(keyValue -> {
            String key = keyValue.getKey().toString(StandardCharsets.UTF_8);
            // ç›‘å¬KEYçš„å˜åŒ–
            watch(key);
            // è§£ææœåŠ¡ä¿¡æ¯
            String value = keyValue.getValue().toString(StandardCharsets.UTF_8);
            return JSONUtil.toBean(value, ServiceMetaInfo.class);
        }).collect(Collectors.toList());

        // å†™å…¥æœåŠ¡ç¼“å­˜
        registryServiceMultiCache.writeCache(serviceKey, serviceMetaInfoList);
        return serviceMetaInfoList;
    } catch (Exception e) {
        throw new RuntimeException("æœåŠ¡å‘ç°å¤±è´¥", e);
    }
}
```

#### ç­–ç•¥äºŒï¼šWatchå®æ—¶æ›´æ–°
```mermaid
sequenceDiagram
    participant Consumer as æœåŠ¡æ¶ˆè´¹è€…
    participant Watch as Watchç›‘å¬
    participant Registry as æ³¨å†Œä¸­å¿ƒ
    participant Cache as æœ¬åœ°ç¼“å­˜

    Consumer->>Registry: é¦–æ¬¡æŸ¥è¯¢æœåŠ¡
    Registry-->>Consumer: è¿”å›æœåŠ¡åˆ—è¡¨
    Consumer->>Watch: å»ºç«‹Watchç›‘å¬
    Consumer->>Cache: å†™å…¥ç¼“å­˜

    Note over Registry: æœåŠ¡å®ä¾‹å˜åŒ–
    Registry->>Watch: æ¨é€å˜æ›´äº‹ä»¶
    Watch->>Cache: æ¸…ç†ç›¸å…³ç¼“å­˜

    Note over Consumer: ä¸‹æ¬¡æŸ¥è¯¢æ—¶é‡æ–°è·å–
```

#### Watchæœºåˆ¶å®ç°
```java
@Override
public void watch(String serviceNodeKey) {
    Watch watchClient = client.getWatchClient();
    // ä¹‹å‰æœªè¢«ç›‘å¬ï¼Œå¼€å¯ç›‘å¬
    boolean newWatch = watchingKeySet.add(serviceNodeKey);
    if(newWatch){
        watchClient.watch(ByteSequence.from(serviceNodeKey, StandardCharsets.UTF_8), response -> {
            for(WatchEvent event : response.getEvents()){
                switch(event.getEventType()){
                    // key åˆ é™¤æ—¶å€™è§¦å‘
                    case DELETE:
                        // æ¸…ç†æ³¨å†ŒæœåŠ¡ç¼“å­˜
                        registryServiceMultiCache.clearCache(serviceNodeKey);
                        break;
                    case PUT:
                    default:
                        break;
                }
            }
        });
    }
}
```

### 3. å¤šæ³¨å†Œä¸­å¿ƒç¼“å­˜æ”¯æŒ

#### ZooKeeperæ³¨å†Œä¸­å¿ƒç¼“å­˜
```java
@Override
public List<ServiceMetaInfo> serviceDiscovery(String serviceKey) {
    // ä¼˜å…ˆä»ç¼“å­˜è·å–
    List<ServiceMetaInfo> cachedServiceMetaInfoList =
        registryServiceCache.readCache(serviceKey);
    if (cachedServiceMetaInfoList != null) {
        return cachedServiceMetaInfoList;
    }
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ³¨å†Œä¸­å¿ƒè¯»å–å¹¶è®¾ç½®ç›‘å¬
    return discoverAndCache(serviceKey);
}

private List<ServiceMetaInfo> discoverAndCache(String serviceKey) {
    try {
        // ä»æ³¨å†Œä¸­å¿ƒè¯»å–
        Collection<ServiceInstance<ServiceMetaInfo>> serviceInstanceCollection =
            serviceDiscovery.queryForInstances(serviceKey);
        // é¦–æ¬¡å‘ç°ï¼Œå»ºç«‹ç›‘å¬
        watch(serviceKey);
        // å†™å…¥ç¼“å­˜
        List<ServiceMetaInfo> serviceMetaInfoList = serviceInstanceCollection.stream()
                .map(ServiceInstance::getPayload)
                .collect(Collectors.toList());
        registryServiceCache.writeCache(serviceKey, serviceMetaInfoList);
        return serviceMetaInfoList;
    } catch (Exception e) {
        throw new RuntimeException("æœåŠ¡å‘ç°å¤±è´¥", e);
    }
}
```

#### Consulæ³¨å†Œä¸­å¿ƒç¼“å­˜
```java
@Override
public List<ServiceMetaInfo> serviceDiscovery(String serviceKey) {
    List<ServiceMetaInfo> cachedServices = registryServiceCache.readCache(serviceKey);
    if (cachedServices != null && !cachedServices.isEmpty()) {
        return cachedServices;
    }

    List<ServiceHealth> serviceHealthList =
        healthClient.getHealthyServiceInstances(serviceKey).getResponse();
    List<ServiceMetaInfo> serviceMetaInfoList = serviceHealthList.stream()
            .map(serviceHealth -> {
                Map<String, String> meta = serviceHealth.getService().getMeta();
                try {
                    return serializer.deserialize(
                        meta.get("serviceMetaInfo").getBytes(),
                        ServiceMetaInfo.class
                    );
                } catch (IOException e) {
                    throw new RuntimeException("Failed to deserialize service meta info", e);
                }
            })
            .collect(Collectors.toList());

    // å†™å…¥ç¼“å­˜
    registryServiceCache.writeCache(serviceKey, serviceMetaInfoList);
    return serviceMetaInfoList;
}
```

## ğŸ”’ ä¸€è‡´æ€§ä¿éšœæœºåˆ¶

### 1. ç¼“å­˜å¤±æ•ˆç­–ç•¥

#### åŸºäºäº‹ä»¶çš„ç¼“å­˜å¤±æ•ˆ
```mermaid
graph TD
    A[æœåŠ¡å˜æ›´äº‹ä»¶] --> B{äº‹ä»¶ç±»å‹}
    B -->|DELETE| C[æ¸…ç†ç¼“å­˜]
    B -->|PUT| D[ä¿ç•™ç¼“å­˜]
    B -->|EXPIRE| E[æ¸…ç†ç¼“å­˜]

    C --> F[ä¸‹æ¬¡æŸ¥è¯¢é‡æ–°è·å–]
    D --> G[ç¼“å­˜ç»§ç»­æœ‰æ•ˆ]
    E --> F

    style C fill:#ffcdd2
    style F fill:#e8f5e8
```

#### å®é™…å®ç°
```java
// Etcd Watchäº‹ä»¶å¤„ç†
@Override
public void watch(String serviceNodeKey) {
    Watch watchClient = client.getWatchClient();
    boolean newWatch = watchingKeySet.add(serviceNodeKey);
    if(newWatch){
        watchClient.watch(ByteSequence.from(serviceNodeKey, StandardCharsets.UTF_8), response -> {
            for(WatchEvent event : response.getEvents()){
                switch(event.getEventType()){
                    case DELETE:
                        // æœåŠ¡ä¸‹çº¿ï¼Œç«‹å³æ¸…ç†ç¼“å­˜
                        registryServiceMultiCache.clearCache(serviceNodeKey);
                        log.info("æœåŠ¡ä¸‹çº¿ï¼Œæ¸…ç†ç¼“å­˜: {}", serviceNodeKey);
                        break;
                    case PUT:
                        // æœåŠ¡æ›´æ–°ï¼Œä¿ç•™ç¼“å­˜ï¼ˆä¸‹æ¬¡æŸ¥è¯¢æ—¶ä¼šè·å–æœ€æ–°æ•°æ®ï¼‰
                        log.debug("æœåŠ¡æ›´æ–°äº‹ä»¶: {}", serviceNodeKey);
                        break;
                    default:
                        break;
                }
            }
        });
    }
}
```

### 2. ç¼“å­˜ä¸€è‡´æ€§çº§åˆ«

#### æœ€ç»ˆä¸€è‡´æ€§æ¨¡å‹
```mermaid
timeline
    title ç¼“å­˜ä¸€è‡´æ€§æ—¶é—´çº¿

    T0 : æœåŠ¡å®ä¾‹ä¸‹çº¿
       : æ³¨å†Œä¸­å¿ƒæ›´æ–°

    T1 : Watchäº‹ä»¶è§¦å‘
       : æ¸…ç†æœ¬åœ°ç¼“å­˜

    T2 : ä¸‹æ¬¡æœåŠ¡å‘ç°
       : è·å–æœ€æ–°æ•°æ®
       : ç¼“å­˜é‡å»º

    T3 : ä¸€è‡´æ€§è¾¾æˆ
       : ç¼“å­˜ä¸æ³¨å†Œä¸­å¿ƒåŒæ­¥
```

#### ä¸€è‡´æ€§ä¿éšœç­–ç•¥
| ç­–ç•¥ | ä¸€è‡´æ€§çº§åˆ« | æ€§èƒ½å½±å“ | é€‚ç”¨åœºæ™¯ |
|------|-----------|---------|----------|
| ç«‹å³å¤±æ•ˆ | å¼ºä¸€è‡´æ€§ | é«˜ | å…³é”®ä¸šåŠ¡æœåŠ¡ |
| å»¶è¿Ÿå¤±æ•ˆ | æœ€ç»ˆä¸€è‡´æ€§ | ä¸­ | ä¸€èˆ¬ä¸šåŠ¡æœåŠ¡ |
| å®šæœŸæ ¡éªŒ | å¼±ä¸€è‡´æ€§ | ä½ | éå…³é”®æœåŠ¡ |

### 3. ç¼“å­˜æ•°æ®æ ¡éªŒ

#### æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
```java
public class CacheConsistencyChecker {

    /**
     * æ ¡éªŒç¼“å­˜æ•°æ®å®Œæ•´æ€§
     */
    public boolean validateCacheIntegrity(String serviceKey) {
        List<ServiceMetaInfo> cachedServices =
            registryServiceMultiCache.readCache(serviceKey);

        if (cachedServices == null || cachedServices.isEmpty()) {
            return true; // ç©ºç¼“å­˜è®¤ä¸ºæ˜¯ä¸€è‡´çš„
        }

        try {
            // ä»æ³¨å†Œä¸­å¿ƒè·å–æœ€æ–°æ•°æ®
            List<ServiceMetaInfo> latestServices =
                registryClient.serviceDiscovery(serviceKey);

            // æ¯”è¾ƒæ•°æ®ä¸€è‡´æ€§
            return isDataConsistent(cachedServices, latestServices);

        } catch (Exception e) {
            log.warn("ç¼“å­˜ä¸€è‡´æ€§æ ¡éªŒå¤±è´¥: {}", serviceKey, e);
            return false;
        }
    }

    private boolean isDataConsistent(List<ServiceMetaInfo> cached,
                                   List<ServiceMetaInfo> latest) {
        if (cached.size() != latest.size()) {
            return false;
        }

        Set<String> cachedNodes = cached.stream()
            .map(ServiceMetaInfo::getServiceNodeKey)
            .collect(Collectors.toSet());

        Set<String> latestNodes = latest.stream()
            .map(ServiceMetaInfo::getServiceNodeKey)
            .collect(Collectors.toSet());

        return cachedNodes.equals(latestNodes);
    }
}
```

### 4. æ•…éšœæ¢å¤æœºåˆ¶

#### æ³¨å†Œä¸­å¿ƒä¸å¯ç”¨æ—¶çš„å¤„ç†
```java
@Override
public List<ServiceMetaInfo> serviceDiscovery(String serviceKey) {
    // ä¼˜å…ˆä»ç¼“å­˜è·å–
    List<ServiceMetaInfo> cachedServices =
        registryServiceMultiCache.readCache(serviceKey);

    try {
        // å°è¯•ä»æ³¨å†Œä¸­å¿ƒè·å–æœ€æ–°æ•°æ®
        List<ServiceMetaInfo> latestServices = queryFromRegistry(serviceKey);

        // æ›´æ–°ç¼“å­˜
        registryServiceMultiCache.writeCache(serviceKey, latestServices);
        return latestServices;

    } catch (Exception e) {
        log.warn("æ³¨å†Œä¸­å¿ƒä¸å¯ç”¨ï¼Œä½¿ç”¨ç¼“å­˜æ•°æ®: {}", serviceKey, e);

        // æ³¨å†Œä¸­å¿ƒä¸å¯ç”¨ï¼Œè¿”å›ç¼“å­˜æ•°æ®
        if (cachedServices != null && !cachedServices.isEmpty()) {
            return cachedServices;
        }

        // ç¼“å­˜ä¹Ÿä¸ºç©ºï¼ŒæŠ›å‡ºå¼‚å¸¸
        throw new RuntimeException("æœåŠ¡å‘ç°å¤±è´¥ï¼Œæ³¨å†Œä¸­å¿ƒä¸å¯ç”¨ä¸”æ— ç¼“å­˜æ•°æ®", e);
    }
}
```

#### ç¼“å­˜é¢„çƒ­æœºåˆ¶
```java
public class CacheWarmupService {

    @PostConstruct
    public void warmupCache() {
        // é¢„åŠ è½½å…³é”®æœåŠ¡
        List<String> criticalServices = getCriticalServices();

        for (String serviceKey : criticalServices) {
            try {
                List<ServiceMetaInfo> services =
                    registryClient.serviceDiscovery(serviceKey);
                registryServiceMultiCache.writeCache(serviceKey, services);
                log.info("é¢„çƒ­ç¼“å­˜æˆåŠŸ: {}", serviceKey);
            } catch (Exception e) {
                log.warn("é¢„çƒ­ç¼“å­˜å¤±è´¥: {}", serviceKey, e);
            }
        }
    }

    private List<String> getCriticalServices() {
        // è¿”å›å…³é”®æœåŠ¡åˆ—è¡¨
        return Arrays.asList(
            "UserService:1.0",
            "OrderService:1.0",
            "PaymentService:1.0"
        );
    }
}
```
            }
        }
    });
}
```

#### ä¼˜ç¼ºç‚¹åˆ†æ

**ä¼˜ç‚¹**ï¼š
- è¿‘å®æ—¶æ›´æ–°ï¼Œå˜æ›´æ„ŸçŸ¥å»¶è¿Ÿä½
- æŒ‰éœ€æ›´æ–°ï¼Œä»…å¤„ç†å˜æ›´éƒ¨åˆ†
- å‡å°‘ä¸å¿…è¦çš„å…¨é‡æ‹‰å–

**ç¼ºç‚¹**ï¼š
- ä¾èµ–æ³¨å†Œä¸­å¿ƒçš„é€šçŸ¥æœºåˆ¶
- éœ€è¦å¤„ç†è¿æ¥æ–­å¼€ã€æ¶ˆæ¯ä¸¢å¤±ç­‰å¼‚å¸¸
- é•¿è¿æ¥ç»´æŠ¤å¼€é”€

### 3. æŒ‰éœ€æ›´æ–°ç­–ç•¥

åœ¨è®¿é—®ç¼“å­˜æ—¶æ£€æŸ¥æ•°æ®æ˜¯å¦è¿‡æœŸï¼ŒæŒ‰éœ€ä»æ³¨å†Œä¸­å¿ƒè·å–æœ€æ–°æ•°æ®ã€‚

```mermaid
graph TD
    A[è·å–æœåŠ¡å®ä¾‹] --> B{ç¼“å­˜æ˜¯å¦å­˜åœ¨?}
    B -->|å¦| C[ä»æ³¨å†Œä¸­å¿ƒè·å–]
    B -->|æ˜¯| D{ç¼“å­˜æ˜¯å¦è¿‡æœŸ?}
    D -->|æ˜¯| C
    D -->|å¦| E[ä½¿ç”¨ç¼“å­˜æ•°æ®]
    C --> F[æ›´æ–°ç¼“å­˜]
    F --> E
```

#### å®ç°æ–¹å¼

```java
public List<ServiceInstance> getServiceInstances(String serviceName) {
    // æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨ä¸”æœªè¿‡æœŸ
    CacheEntry entry = cache.get(serviceName);
    if (entry == null || entry.isExpired()) {
        // ç¼“å­˜ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸï¼Œä»æ³¨å†Œä¸­å¿ƒè·å–
        List<ServiceInstance> instances = registryService.getInstances(serviceName);
        if (instances != null && !instances.isEmpty()) {
            cache.put(serviceName, new CacheEntry(instances));
            return instances;
        }
        // å¦‚æœè·å–å¤±è´¥ä½†ç¼“å­˜å­˜åœ¨ï¼Œè¿”å›è¿‡æœŸæ•°æ®
        if (entry != null) {
            log.warn("Using expired cache for service: " + serviceName);
            return entry.getInstances();
        }
        return Collections.emptyList();
    }
    
    // è¿”å›ç¼“å­˜æ•°æ®
    return entry.getInstances();
}
```

#### ä¼˜ç¼ºç‚¹åˆ†æ

**ä¼˜ç‚¹**ï¼š
- æŒ‰éœ€è·å–ï¼Œå‡å°‘ä¸å¿…è¦çš„æ›´æ–°
- èµ„æºåˆ©ç”¨æ›´é«˜æ•ˆ
- è‡ªé€‚åº”è®¿é—®é¢‘ç‡

**ç¼ºç‚¹**ï¼š
- é¦–æ¬¡è®¿é—®æˆ–è¿‡æœŸåçš„è®¿é—®å»¶è¿Ÿè¾ƒé«˜
- å¹¶å‘åœºæ™¯ä¸‹å¯èƒ½é‡å¤è·å–
- éœ€è¦è°¨æ…è®¾ç½®è¿‡æœŸæ—¶é—´

### 4. ç»„åˆç­–ç•¥

ç»“åˆä»¥ä¸Šä¸‰ç§ç­–ç•¥çš„ä¼˜ç‚¹ï¼Œå®ç°å¤šå±‚æ¬¡çš„ç¼“å­˜æ›´æ–°æœºåˆ¶ã€‚

```mermaid
graph TD
    A[æœåŠ¡ç¼“å­˜æ›´æ–°æœºåˆ¶] --> B[å®æ—¶æ›´æ–°å±‚]
    A --> C[å®šæœŸæ›´æ–°å±‚]
    A --> D[æŒ‰éœ€æ›´æ–°å±‚]
    
    B --> B1[Watchæœºåˆ¶]
    B --> B2[å˜æ›´æ¨é€]
    
    C --> C1[å®šæ—¶å…¨é‡åŒæ­¥]
    C --> C2[å·®å¼‚ä¿®å¤]
    
    D --> D1[ç¼“å­˜è¿‡æœŸæ£€æŸ¥]
    D --> D2[æŒ‰éœ€åŠ è½½]
```

#### å®ç°è¦ç‚¹

1. **åŸºç¡€å±‚**ï¼šä½¿ç”¨Watchæœºåˆ¶å®æ—¶ç›‘å¬å˜æ›´
2. **è¡¥å¿å±‚**ï¼šå®šæœŸæ‰§è¡Œå…¨é‡åŒæ­¥ï¼Œä¿®å¤å¯èƒ½çš„ä¸ä¸€è‡´
3. **å…œåº•å±‚**ï¼šåœ¨ç¼“å­˜è®¿é—®æ—¶æ£€æŸ¥è¿‡æœŸçŠ¶æ€ï¼Œå¿…è¦æ—¶åˆ·æ–°
4. **å¼‚å¸¸å¤„ç†**ï¼šå„å±‚æ¬¡ä¹‹é—´äº’ä¸ºå¤‡ä»½ï¼Œç¡®ä¿ç³»ç»Ÿå¯ç”¨æ€§

## ç¼“å­˜æ•°æ®ä¸€è‡´æ€§ä¿éšœ

### 1. ä¸€è‡´æ€§æ¨¡å‹ä¸æŒ‘æˆ˜

åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œç¼“å­˜ä¸€è‡´æ€§é¢ä¸´å¤šç§æŒ‘æˆ˜ï¼š

#### ä¸€è‡´æ€§æ¨¡å‹

- **å¼ºä¸€è‡´æ€§**ï¼šç¼“å­˜æ•°æ®å§‹ç»ˆä¸æ³¨å†Œä¸­å¿ƒä¿æŒåŒæ­¥ï¼Œä»»ä½•å˜æ›´ç«‹å³å¯è§
- **æœ€ç»ˆä¸€è‡´æ€§**ï¼šåœ¨ä¸€å®šæ—¶é—´çª—å£åï¼Œç¼“å­˜æ•°æ®ä¼šä¸æ³¨å†Œä¸­å¿ƒè¾¾æˆä¸€è‡´
- **å¼±ä¸€è‡´æ€§**ï¼šå…è®¸ç¼“å­˜ä¸æ³¨å†Œä¸­å¿ƒä¹‹é—´å­˜åœ¨ä¸€å®šç¨‹åº¦çš„ä¸ä¸€è‡´

åœ¨å®é™…ç³»ç»Ÿä¸­ï¼Œé€šå¸¸é‡‡ç”¨æœ€ç»ˆä¸€è‡´æ€§æ¨¡å‹ï¼Œåœ¨æ€§èƒ½å’Œä¸€è‡´æ€§ä¹‹é—´å–å¾—å¹³è¡¡ã€‚

#### ä¸€è‡´æ€§æŒ‘æˆ˜

```mermaid
graph TD
    A[ç¼“å­˜ä¸€è‡´æ€§æŒ‘æˆ˜] --> B[ç½‘ç»œå»¶è¿Ÿ]
    A --> C[æ¶ˆæ¯ä¸¢å¤±]
    A --> D[å¹¶å‘æ›´æ–°]
    A --> E[ç³»ç»Ÿæ•…éšœ]
    
    B --> B1[é€šçŸ¥ä¼ æ’­æ—¶é—´å·®]
    C --> C1[è¿æ¥ä¸­æ–­]
    C --> C2[è¶…æ—¶]
    D --> D1[æ›´æ–°å†²çª]
    E --> E1[æ¶ˆè´¹è€…å´©æºƒ]
    E --> E2[æ³¨å†Œä¸­å¿ƒä¸å¯ç”¨]
```

- **ç½‘ç»œå»¶è¿Ÿ**ï¼šå˜æ›´é€šçŸ¥ä¼ æ’­éœ€è¦æ—¶é—´ï¼Œå¯¼è‡´çŸ­æš‚çš„ä¸ä¸€è‡´
- **æ¶ˆæ¯ä¸¢å¤±**ï¼šWatchè¿æ¥ä¸­æ–­å¯èƒ½å¯¼è‡´å˜æ›´é€šçŸ¥ä¸¢å¤±
- **å¹¶å‘æ›´æ–°**ï¼šå¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¯¹åŒä¸€ç¼“å­˜æ¡ç›®çš„å¹¶å‘æ›´æ–°
- **ç³»ç»Ÿæ•…éšœ**ï¼šæ¶ˆè´¹è€…æˆ–æ³¨å†Œä¸­å¿ƒæ•…éšœå¯¼è‡´çš„æ›´æ–°ä¸­æ–­

### 2. ç‰ˆæœ¬æ§åˆ¶ä¸å†²çªè§£å†³

åˆ©ç”¨Etcdç­‰æ³¨å†Œä¸­å¿ƒæä¾›çš„ç‰ˆæœ¬æœºåˆ¶ï¼Œç¡®ä¿æŒ‰æ­£ç¡®é¡ºåºåº”ç”¨å˜æ›´ã€‚

```mermaid
sequenceDiagram
    participant C as ç¼“å­˜
    participant R as æ³¨å†Œä¸­å¿ƒ
    
    Note over C: ç¼“å­˜ç‰ˆæœ¬: v1
    R->>C: æ›´æ–°é€šçŸ¥(v3)
    Note over C: åº”ç”¨æ›´æ–°, ç¼“å­˜ç‰ˆæœ¬: v3
    R->>C: æ›´æ–°é€šçŸ¥(v2)
    Note over C: å¿½ç•¥æ—§ç‰ˆæœ¬æ›´æ–°
```

#### å®ç°æ–¹å¼

```java
public void updateCacheWithVersion(String serviceName, ServiceInstance instance) {
    CacheEntry entry = cache.get(serviceName);
    if (entry != null) {
        // åªæœ‰å½“æ–°ç‰ˆæœ¬å¤§äºå½“å‰ç‰ˆæœ¬æ—¶æ‰æ›´æ–°
        if (instance.getVersion() > entry.getVersion()) {
            entry.updateInstance(instance);
        } else {
            log.debug("Ignoring outdated update for service: " + serviceName);
        }
    } else {
        // ç¼“å­˜ä¸å­˜åœ¨ï¼Œç›´æ¥æ·»åŠ 
        cache.put(serviceName, new CacheEntry(instance));
    }
}
```

### 3. å®šæœŸå…¨é‡æ ¡éªŒ

é€šè¿‡å®šæœŸä¸æ³¨å†Œä¸­å¿ƒè¿›è¡Œå…¨é‡æ•°æ®æ¯”å¯¹ï¼Œå‘ç°å¹¶ä¿®å¤æ½œåœ¨çš„ä¸ä¸€è‡´ã€‚

#### å®ç°æ–¹å¼

```java
@Scheduled(fixedRate = 300000)  // æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
public void validateCacheConsistency() {
    for (String serviceName : cache.keySet()) {
        CacheEntry cachedEntry = cache.get(serviceName);
        if (cachedEntry != null) {
            try {
                // ä»æ³¨å†Œä¸­å¿ƒè·å–æœ€æ–°æ•°æ®
                List<ServiceInstance> latestInstances = 
                    registryService.getInstances(serviceName);
                
                // æ£€æŸ¥ä¸ä¸€è‡´
                if (isInconsistent(cachedEntry.getInstances(), latestInstances)) {
                    log.warn("Detected cache inconsistency for service: " + serviceName);
                    
                    // æ›´æ–°ç¼“å­˜
                    cache.put(serviceName, new CacheEntry(latestInstances));
                    
                    // è®°å½•æŒ‡æ ‡
                    metrics.incrementCacheInconsistencyCount();
                }
            } catch (Exception e) {
                log.error("Failed to validate cache for service: " + serviceName, e);
            }
        }
    }
}
```

### 4. å¢é‡æ›´æ–°ä¸å·®å¼‚å¤„ç†

é’ˆå¯¹æœåŠ¡åˆ—è¡¨çš„å˜æ›´ï¼Œå®ç°ç²¾ç¡®çš„å¢é‡æ›´æ–°ï¼Œè€Œéç®€å•çš„å…¨é‡æ›¿æ¢ã€‚

#### å®ç°æ–¹å¼

```java
public void processDiff(String serviceName, List<ServiceInstance> latestInstances) {
    Map<String, ServiceInstance> latestMap = new HashMap<>();
    for (ServiceInstance instance : latestInstances) {
        latestMap.put(instance.getId(), instance);
    }
    
    CacheEntry entry = cache.get(serviceName);
    if (entry != null) {
        Map<String, ServiceInstance> currentMap = new HashMap<>();
        for (ServiceInstance instance : entry.getInstances()) {
            currentMap.put(instance.getId(), instance);
        }
        
        // æ‰¾å‡ºéœ€è¦æ·»åŠ çš„å®ä¾‹
        Set<String> idsToAdd = new HashSet<>(latestMap.keySet());
        idsToAdd.removeAll(currentMap.keySet());
        
        // æ‰¾å‡ºéœ€è¦åˆ é™¤çš„å®ä¾‹
        Set<String> idsToRemove = new HashSet<>(currentMap.keySet());
        idsToRemove.removeAll(latestMap.keySet());
        
        // æ‰¾å‡ºéœ€è¦æ›´æ–°çš„å®ä¾‹
        Set<String> idsToUpdate = new HashSet<>(latestMap.keySet());
        idsToUpdate.retainAll(currentMap.keySet());
        
        // åº”ç”¨å˜æ›´
        for (String id : idsToAdd) {
            entry.addInstance(latestMap.get(id));
        }
        
        for (String id : idsToRemove) {
            entry.removeInstance(id);
        }
        
        for (String id : idsToUpdate) {
            ServiceInstance latest = latestMap.get(id);
            ServiceInstance current = currentMap.get(id);
            
            if (latest.getVersion() > current.getVersion()) {
                entry.updateInstance(latest);
            }
        }
    } else {
        // ç¼“å­˜ä¸å­˜åœ¨ï¼Œç›´æ¥æ·»åŠ 
        cache.put(serviceName, new CacheEntry(latestInstances));
    }
}
```

### 5. å¼‚å¸¸å¤„ç†ä¸å®¹é”™æœºåˆ¶

è®¾è®¡å¥å£®çš„å¼‚å¸¸å¤„ç†æœºåˆ¶ï¼Œç¡®ä¿åœ¨å„ç§æ•…éšœåœºæ™¯ä¸‹ç¼“å­˜ç³»ç»Ÿä»èƒ½æ­£å¸¸å·¥ä½œã€‚

#### Watchè¿æ¥æ–­å¼€å¤„ç†

```java
public void establishWatchWithRetry(String serviceName) {
    while (!shutdown) {
        try {
            watchService(serviceName);
            // æ­£å¸¸æƒ…å†µä¸‹ï¼ŒwatchServiceä¼šé˜»å¡ï¼Œå¦‚æœè¿”å›è¡¨ç¤ºè¿æ¥æ–­å¼€
            log.warn("Watch connection for " + serviceName + " disconnected, retrying...");
        } catch (Exception e) {
            log.error("Watch error for service: " + serviceName, e);
        }
        
        // é€€é¿é‡è¯•
        try {
            Thread.sleep(retryIntervalMs);
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            break;
        }
    }
}
```

#### æ³¨å†Œä¸­å¿ƒæš‚æ—¶ä¸å¯ç”¨çš„å¤„ç†

```java
public List<ServiceInstance> getServiceInstancesWithFallback(String serviceName) {
    try {
        // å°è¯•è·å–æœ€æ–°æ•°æ®
        return getServiceInstances(serviceName);
    } catch (RegistryCenterException e) {
        // æ³¨å†Œä¸­å¿ƒä¸å¯ç”¨ï¼Œä½¿ç”¨ç¼“å­˜æ•°æ®
        CacheEntry entry = cache.get(serviceName);
        if (entry != null) {
            log.warn("Registry center unavailable, using cached data for: " + serviceName);
            return entry.getInstances();
        }
        throw e;  // ç¼“å­˜ä¹Ÿä¸å­˜åœ¨ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸
    }
}
```

### 6. ç¼“å­˜è¿‡æœŸæœºåˆ¶

ä¸ºç¼“å­˜è®¾ç½®åˆç†çš„è¿‡æœŸæ—¶é—´ï¼Œç¡®ä¿å³ä½¿å‡ºç°æ›´æ–°å¤±è´¥ï¼Œè¿‡æœŸçš„ç¼“å­˜æœ€ç»ˆä¹Ÿä¼šè¢«åˆ·æ–°ã€‚

#### ç¼“å­˜æ¡ç›®å®ç°

```java
public class CacheEntry {
    private final List<ServiceInstance> instances;
    private final long creationTime;
    private final AtomicLong lastUpdateTime;
    private final AtomicLong accessCount;
    private final long ttlMs;
    
    public CacheEntry(List<ServiceInstance> instances) {
        this(instances, DEFAULT_TTL_MS);
    }
    
    public CacheEntry(List<ServiceInstance> instances, long ttlMs) {
        this.instances = new CopyOnWriteArrayList<>(instances);
        this.creationTime = System.currentTimeMillis();
        this.lastUpdateTime = new AtomicLong(this.creationTime);
        this.accessCount = new AtomicLong(0);
        this.ttlMs = ttlMs;
    }
    
    public boolean isExpired() {
        return System.currentTimeMillis() - lastUpdateTime.get() > ttlMs;
    }
    
    public List<ServiceInstance> getInstances() {
        accessCount.incrementAndGet();
        return new ArrayList<>(instances);
    }
    
    // å…¶ä»–æ–¹æ³•: updateInstance, addInstance, removeInstance ç­‰
}
```

## ç¼“å­˜ä¸€è‡´æ€§ä¿éšœçš„æœ€ä½³å®è·µ

### 1. å¤šå±‚æ¬¡æ›´æ–°ç­–ç•¥

ç»“åˆå¤šç§æ›´æ–°æœºåˆ¶ï¼Œæ„å»ºç¨³å›ºçš„ç¼“å­˜æ›´æ–°ä½“ç³»ï¼š

```mermaid
graph TD
    A[ç¼“å­˜æ›´æ–°ç­–ç•¥] --> B[ä¸»åŠ¨æ›´æ–°]
    A --> C[è¢«åŠ¨æ›´æ–°]
    A --> D[åº”æ€¥é¢„æ¡ˆ]
    
    B --> B1[Watchå®æ—¶æ¨é€]
    C --> C1[å®šæœŸå…¨é‡åŒæ­¥]
    C --> C2[è®¿é—®æ—¶æ£€æŸ¥è¿‡æœŸ]
    D --> D1[ä¸€è‡´æ€§æ£€æµ‹ä¿®å¤]
    D --> D2[æ•…éšœé™çº§]
```

- **å®æ—¶æ¨é€**ï¼šåŸºäºWatchæœºåˆ¶çš„å®æ—¶æ›´æ–°ï¼Œæ˜¯ä¸»è¦æ›´æ–°æ‰‹æ®µ
- **å®šæœŸåŒæ­¥**ï¼šä½œä¸ºè¡¥å……ï¼Œå®šæœŸå…¨é‡åŒæ­¥ç¡®ä¿ä¸é—æ¼å˜æ›´
- **è¿‡æœŸæ£€æŸ¥**ï¼šè®¿é—®ç¼“å­˜æ—¶æ£€æŸ¥è¿‡æœŸçŠ¶æ€ï¼ŒæŒ‰éœ€æ›´æ–°
- **ä¸€è‡´æ€§ä¿®å¤**ï¼šå®šæœŸæ£€æµ‹å¹¶ä¿®å¤æ½œåœ¨çš„ä¸ä¸€è‡´
- **æ•…éšœé™çº§**ï¼šå½“æ³¨å†Œä¸­å¿ƒä¸å¯ç”¨æ—¶ï¼Œç»§ç»­ä½¿ç”¨ç¼“å­˜æä¾›æœåŠ¡

### 2. Watchæœºåˆ¶æœ€ä½³å®è·µ

ä½¿ç”¨Etcdçš„Watchæœºåˆ¶æ—¶ï¼Œåº”æ³¨æ„ä»¥ä¸‹æœ€ä½³å®è·µï¼š

- **æŒ‰æœåŠ¡ç²’åº¦ç›‘å¬**ï¼šå¯¹æ¯ä¸ªå…³æ³¨çš„æœåŠ¡å•ç‹¬å»ºç«‹Watchè¿æ¥
- **æ–­çº¿é‡è¿**ï¼šå®ç°è‡ªåŠ¨é‡è¿æœºåˆ¶ï¼Œç¡®ä¿è¿æ¥å¯é æ€§
- **å¢é‡æ¢å¤**ï¼šé‡è¿æ—¶è®°å½•ä¸Šæ¬¡æ›´æ–°ç‰ˆæœ¬ï¼Œè¯·æ±‚é—æ¼çš„æ›´æ–°
- **å¼‚æ­¥å¤„ç†**ï¼šé€šçŸ¥å¤„ç†åº”åœ¨å•ç‹¬çº¿ç¨‹ä¸­è¿›è¡Œï¼Œä¸é˜»å¡ä¸»ä¸šåŠ¡çº¿ç¨‹
- **æ‰¹é‡å¤„ç†**ï¼šåˆå¹¶çŸ­æ—¶é—´å†…çš„å¤šæ¬¡æ›´æ–°ï¼Œå‡å°‘å¤„ç†å¼€é”€

### 3. æ•°æ®ä¸€è‡´æ€§ä¿éšœæªæ–½

ç»¼åˆå¤šç§æœºåˆ¶ç¡®ä¿æ•°æ®ä¸€è‡´æ€§ï¼š

- **ç‰ˆæœ¬æ§åˆ¶**ï¼šä½¿ç”¨Etcdæä¾›çš„ä¿®è®¢ç‰ˆæœ¬è·Ÿè¸ªæ•°æ®å˜æ›´
- **CASæ“ä½œ**ï¼šä½¿ç”¨Compare-And-Swapä¿è¯æ›´æ–°åŸå­æ€§
- **å¢é‡å¯¹æ¯”**ï¼šå®šæœŸæ‰§è¡Œå¢é‡æ£€æŸ¥ï¼Œåªä¿®å¤ä¸ä¸€è‡´çš„éƒ¨åˆ†
- **TTLæœºåˆ¶**ï¼šä¸ºç¼“å­˜è®¾ç½®åˆç†çš„ç”Ÿå­˜æœŸï¼Œç¡®ä¿æœ€ç»ˆä¸€è‡´æ€§
- **åŒé‡éªŒè¯**ï¼šé‡è¦æ“ä½œå‰åŒé‡æ£€æŸ¥ç¼“å­˜ä¸æ³¨å†Œä¸­å¿ƒ

### 4. æ€§èƒ½ä¸ä¸€è‡´æ€§å¹³è¡¡

æ ¹æ®å…·ä½“åº”ç”¨åœºæ™¯ï¼Œè°ƒæ•´æ›´æ–°ç­–ç•¥å’Œå‚æ•°ï¼Œå¹³è¡¡æ€§èƒ½ä¸ä¸€è‡´æ€§ï¼š

| å‚æ•° | ä½å»¶è¿Ÿä¼˜å…ˆ | ä¸€è‡´æ€§ä¼˜å…ˆ | å¹³è¡¡æ¨¡å¼ |
|------|------------|------------|----------|
| ç¼“å­˜TTL | è¾ƒé•¿(5-10åˆ†é’Ÿ) | è¾ƒçŸ­(30-60ç§’) | ä¸­ç­‰(2-5åˆ†é’Ÿ) |
| å…¨é‡åŒæ­¥é—´éš” | è¾ƒé•¿(10åˆ†é’Ÿ) | è¾ƒçŸ­(1åˆ†é’Ÿ) | ä¸­ç­‰(5åˆ†é’Ÿ) |
| Watchæ–­çº¿é‡è¯• | æ…¢é€Ÿé€€é¿ | å¿«é€Ÿé‡è¯• | æ¸è¿›é€€é¿ |
| è¿‡æœŸç­–ç•¥ | å®½æ¾(ç»§ç»­ä½¿ç”¨) | ä¸¥æ ¼(ç«‹å³åˆ·æ–°) | æ¡ä»¶åˆ·æ–° |
| å¼‚å¸¸å¤„ç† | å€¾å‘ä½¿ç”¨ç¼“å­˜ | å€¾å‘æŠ¥é”™ | åŠ¨æ€åˆ¤æ–­ |

### 5. ç›‘æ§ä¸å‘Šè­¦

å»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»ï¼Œç¡®ä¿ç¼“å­˜ç³»ç»Ÿå¥åº·è¿è¡Œï¼š

- **ç¼“å­˜å‘½ä¸­ç‡**ï¼šç›‘æ§ç¼“å­˜è®¿é—®çš„å‘½ä¸­æƒ…å†µ
- **æ›´æ–°å»¶è¿Ÿ**ï¼šç›‘æ§ä»å˜æ›´å‘ç”Ÿåˆ°ç¼“å­˜æ›´æ–°çš„å»¶è¿Ÿ
- **ä¸ä¸€è‡´ç‡**ï¼šç›‘æ§æ£€æµ‹åˆ°çš„ç¼“å­˜ä¸ä¸€è‡´æ¬¡æ•°
- **WatchçŠ¶æ€**ï¼šç›‘æ§Watchè¿æ¥çš„å¥åº·çŠ¶æ€
- **æ³¨å†Œä¸­å¿ƒå¯ç”¨æ€§**ï¼šç›‘æ§ä¸æ³¨å†Œä¸­å¿ƒçš„è¿æ¥çŠ¶æ€

å½“å…³é”®æŒ‡æ ‡å¼‚å¸¸æ—¶ï¼ŒåŠæ—¶è§¦å‘å‘Šè­¦ï¼Œç¡®ä¿è¿ç»´äººå‘˜èƒ½å¤Ÿå¿«é€Ÿå“åº”ã€‚

## æ€»ç»“

æ›´æ–°æœåŠ¡æ³¨å†Œä¿¡æ¯ç¼“å­˜å¹¶ä¿è¯æ•°æ®ä¸€è‡´æ€§æ˜¯æ„å»ºå¯é RPCæ¡†æ¶çš„å…³é”®æŒ‘æˆ˜ä¹‹ä¸€ã€‚é€šè¿‡ç»“åˆWatchæœºåˆ¶çš„å®æ—¶æ›´æ–°ã€å®šæœŸå…¨é‡åŒæ­¥çš„è¡¥å¿æœºåˆ¶ã€ç¼“å­˜è¿‡æœŸçš„å…œåº•ç­–ç•¥ï¼Œä»¥åŠå®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œç›‘æ§ä½“ç³»ï¼Œå¯ä»¥æ„å»ºä¸€ä¸ªæ—¢é«˜æ•ˆåˆå¯é çš„æœåŠ¡å‘ç°ç¼“å­˜ç³»ç»Ÿã€‚

## ğŸ¯ æœ€ä½³å®è·µ

### 1. ç¼“å­˜ç­–ç•¥é€‰æ‹©

#### æ ¹æ®ä¸šåŠ¡ç‰¹æ€§é€‰æ‹©ç­–ç•¥
```java
public class CacheStrategySelector {

    public CacheStrategy selectStrategy(ServiceType serviceType) {
        switch (serviceType) {
            case CRITICAL_SERVICE:
                // å…³é”®æœåŠ¡ï¼šå¼ºä¸€è‡´æ€§ + å®æ—¶æ›´æ–°
                return new StrongConsistencyStrategy();

            case NORMAL_SERVICE:
                // æ™®é€šæœåŠ¡ï¼šæœ€ç»ˆä¸€è‡´æ€§ + Watchæ›´æ–°
                return new EventualConsistencyStrategy();

            case BATCH_SERVICE:
                // æ‰¹å¤„ç†æœåŠ¡ï¼šå¼±ä¸€è‡´æ€§ + å®šæœŸæ›´æ–°
                return new WeakConsistencyStrategy();

            default:
                return new DefaultStrategy();
        }
    }
}
```

### 2. ç›‘æ§å’Œå‘Šè­¦

#### ç¼“å­˜æŒ‡æ ‡ç›‘æ§
```java
@Component
public class CacheMetrics {

    private final AtomicLong cacheHits = new AtomicLong(0);
    private final AtomicLong cacheMisses = new AtomicLong(0);
    private final AtomicLong consistencyErrors = new AtomicLong(0);

    public void recordCacheHit() {
        cacheHits.incrementAndGet();
    }

    public void recordCacheMiss() {
        cacheMisses.incrementAndGet();
    }

    public void recordConsistencyError() {
        consistencyErrors.incrementAndGet();
    }

    public CacheStats getStats() {
        long hits = cacheHits.get();
        long misses = cacheMisses.get();
        double hitRate = hits + misses > 0 ? (double) hits / (hits + misses) : 0.0;

        return CacheStats.builder()
            .hitRate(hitRate)
            .totalHits(hits)
            .totalMisses(misses)
            .consistencyErrors(consistencyErrors.get())
            .build();
    }
}
```

## ğŸ“‹ Ming RPC Frameworkç¼“å­˜æ€»ç»“

é€šè¿‡å®Œå–„çš„æœåŠ¡æ³¨å†Œä¿¡æ¯ç¼“å­˜æ›´æ–°ä¸ä¸€è‡´æ€§ä¿éšœæœºåˆ¶ï¼ŒMing RPC Frameworkå®ç°äº†é«˜æ€§èƒ½å’Œé«˜å¯ç”¨çš„æœåŠ¡å‘ç°èƒ½åŠ›ã€‚

### æ ¸å¿ƒç‰¹æ€§
- âœ… **å¤šçº§ç¼“å­˜**: RegistryServiceMultiCacheæ”¯æŒå¤šæœåŠ¡å¹¶å‘ç¼“å­˜
- âœ… **å®æ—¶æ›´æ–°**: åŸºäºWatchæœºåˆ¶çš„å®æ—¶ç¼“å­˜å¤±æ•ˆ
- âœ… **ä¸€è‡´æ€§ä¿éšœ**: å¤šå±‚æ¬¡çš„ä¸€è‡´æ€§ä¿éšœç­–ç•¥
- âœ… **æ•…éšœæ¢å¤**: å®Œå–„çš„å®¹é”™å’Œæ¢å¤æœºåˆ¶
- âœ… **æ€§èƒ½ç›‘æ§**: å…¨é¢çš„ç¼“å­˜æŒ‡æ ‡ç›‘æ§

### æŠ€æœ¯ä¼˜åŠ¿
- **é«˜æ€§èƒ½**: ConcurrentHashMapæä¾›é«˜å¹¶å‘è¯»å†™èƒ½åŠ›
- **å®æ—¶æ€§**: Watchæœºåˆ¶ç¡®ä¿ç¼“å­˜æ•°æ®çš„å®æ—¶æ€§
- **å¯é æ€§**: å¤šé‡ä¿éšœæœºåˆ¶ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
- **å¯æ‰©å±•**: æ”¯æŒå¤šç§æ³¨å†Œä¸­å¿ƒçš„ç¼“å­˜ç­–ç•¥

### ä¸€è‡´æ€§ä¿éšœ
- **äº‹ä»¶é©±åŠ¨**: åŸºäºæ³¨å†Œä¸­å¿ƒäº‹ä»¶çš„ç¼“å­˜å¤±æ•ˆ
- **æœ€ç»ˆä¸€è‡´æ€§**: é€šè¿‡Watchæœºåˆ¶å®ç°æœ€ç»ˆä¸€è‡´æ€§
- **æ•°æ®æ ¡éªŒ**: å®šæœŸæ ¡éªŒç¡®ä¿æ•°æ®å®Œæ•´æ€§
- **æ•…éšœæ¢å¤**: æ³¨å†Œä¸­å¿ƒä¸å¯ç”¨æ—¶çš„é™çº§ç­–ç•¥

### ä½¿ç”¨å»ºè®®
1. **å…³é”®æœåŠ¡**: ä½¿ç”¨å¼ºä¸€è‡´æ€§ç­–ç•¥ï¼Œå¯ç”¨å®æ—¶ç›‘æ§
2. **æ™®é€šæœåŠ¡**: ä½¿ç”¨æœ€ç»ˆä¸€è‡´æ€§ç­–ç•¥ï¼Œå¹³è¡¡æ€§èƒ½å’Œä¸€è‡´æ€§
3. **æ‰¹å¤„ç†æœåŠ¡**: ä½¿ç”¨å¼±ä¸€è‡´æ€§ç­–ç•¥ï¼Œä¼˜å…ˆè€ƒè™‘æ€§èƒ½
4. **ç›‘æ§å‘Šè­¦**: å»ºç«‹å®Œå–„çš„ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶
5. **æ€§èƒ½è°ƒä¼˜**: æ ¹æ®ä¸šåŠ¡ç‰¹ç‚¹è°ƒæ•´ç¼“å­˜ç­–ç•¥å’Œå‚æ•°

é€šè¿‡è¿™å¥—å®Œæ•´çš„ç¼“å­˜æ›´æ–°ä¸ä¸€è‡´æ€§ä¿éšœæœºåˆ¶ï¼ŒMing RPC Frameworkèƒ½å¤Ÿåœ¨ä¿è¯é«˜æ€§èƒ½çš„åŒæ—¶ï¼Œæœ€å¤§ç¨‹åº¦åœ°ä¿è¯ç¼“å­˜æ•°æ®ä¸æ³¨å†Œä¸­å¿ƒçš„ä¸€è‡´æ€§ï¼Œä¸ºåˆ†å¸ƒå¼ç³»ç»Ÿæä¾›å¯é çš„æœåŠ¡å‘ç°èƒ½åŠ›ã€‚