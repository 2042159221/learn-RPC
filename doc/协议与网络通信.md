# Ming RPC Framework åè®®ä¸ç½‘ç»œé€šä¿¡è¯¦è§£

## ğŸ“– æ¦‚è¿°

åè®®ä¸ç½‘ç»œé€šä¿¡æ˜¯Ming RPC Frameworkçš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ï¼Œè´Ÿè´£åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­å®ç°æœåŠ¡æä¾›è€…å’Œæ¶ˆè´¹è€…ä¹‹é—´çš„å¯é é€šä¿¡ã€‚æ¡†æ¶é‡‡ç”¨å¤šåè®®æ”¯æŒçš„è®¾è®¡ç†å¿µï¼Œæ—¢æä¾›ç®€å•æ˜“ç”¨çš„HTTPåè®®ï¼Œä¹Ÿæ”¯æŒé«˜æ€§èƒ½çš„TCPåè®®ï¼Œæ»¡è¶³ä¸åŒåœºæ™¯çš„éœ€æ±‚ã€‚

### ğŸ¯ è®¾è®¡ç›®æ ‡
1. **é«˜æ€§èƒ½**: é€šè¿‡ä¼˜åŒ–çš„åè®®è®¾è®¡å’Œç½‘ç»œé€šä¿¡å®ç°é«˜ååé‡
2. **å¯é æ€§**: æä¾›å¯é çš„æ¶ˆæ¯ä¼ è¾“å’Œé”™è¯¯å¤„ç†æœºåˆ¶
3. **å¯æ‰©å±•**: æ”¯æŒå¤šç§åè®®å’Œç¼–è§£ç æ–¹å¼
4. **æ˜“è°ƒè¯•**: æä¾›å‹å¥½çš„è°ƒè¯•å’Œç›‘æ§èƒ½åŠ›

### ğŸŒ ç½‘ç»œé€šä¿¡åœ¨RPCä¸­çš„ä½ç½®
```mermaid
graph TD
    A[å®¢æˆ·ç«¯è°ƒç”¨] --> B[åŠ¨æ€ä»£ç†]
    B --> C[åºåˆ—åŒ–]
    C --> D[åè®®ç¼–ç ]
    D --> E[ç½‘ç»œä¼ è¾“]
    E --> F[åè®®è§£ç ]
    F --> G[ååºåˆ—åŒ–]
    G --> H[æœåŠ¡è°ƒç”¨]
    H --> I[å“åº”å¤„ç†]
    I --> J[åè®®ç¼–ç ]
    J --> K[ç½‘ç»œä¼ è¾“]
    K --> L[åè®®è§£ç ]
    L --> M[ååºåˆ—åŒ–]
    M --> N[è¿”å›ç»“æœ]
```

## ğŸ”Œ RPCæ¡†æ¶é‡‡ç”¨çš„åè®®è®¾è®¡

### åè®®è®¾è®¡

æœ¬ RPC æ¡†æ¶é‡‡ç”¨äº†åŸºäº HTTP åè®®çš„é€šä¿¡æ–¹å¼ï¼Œå¹¶åœ¨å…¶ä¸Šæ„å»ºäº†è‡ªå®šä¹‰çš„åº”ç”¨å±‚åè®®ã€‚å…·ä½“åè®®è®¾è®¡å¦‚ä¸‹ï¼š

- **åº•å±‚ä¼ è¾“åè®®**ï¼šHTTP åè®®
- **åº”ç”¨å±‚åè®®**ï¼šè‡ªå®šä¹‰çš„ RPC è¯·æ±‚å“åº”æ ¼å¼
  - **è¯·æ±‚æ ¼å¼**ï¼šåºåˆ—åŒ–åçš„ `RpcRequest` å¯¹è±¡
  - **å“åº”æ ¼å¼**ï¼šåºåˆ—åŒ–åçš„ `RpcResponse` å¯¹è±¡

```mermaid
graph TD
    A[å®¢æˆ·ç«¯] -->|HTTP POST è¯·æ±‚<br>Body: åºåˆ—åŒ–åçš„RpcRequest| B[æœåŠ¡ç«¯]
    B -->|HTTP å“åº”<br>Body: åºåˆ—åŒ–åçš„RpcResponse| A
```

### RPC è¯·æ±‚ä¸å“åº”ç»“æ„

**RpcRequest ç±»ç»“æ„**ï¼š
```java
public class RpcRequest implements Serializable {
    private String serviceName;    // æœåŠ¡åç§°ï¼Œé€šå¸¸æ˜¯æ¥å£å…¨é™å®šå
    private String methodName;     // æ–¹æ³•å
    private Object[] args;         // æ–¹æ³•å‚æ•°å€¼
    private Class<?>[] parameterTypes;  // æ–¹æ³•å‚æ•°ç±»å‹
}
```

**RpcResponse ç±»ç»“æ„**ï¼š
```java
public class RpcResponse implements Serializable {
    private Object data;          // è¿”å›æ•°æ®
    private Class<?> dataType;    // æ•°æ®ç±»å‹
    private String message;       // å“åº”æ¶ˆæ¯
    private Exception exception;  // å¼‚å¸¸ä¿¡æ¯
}
```

### ä¸ºä»€ä¹ˆè¦è‡ªå®šä¹‰åè®®ï¼Ÿ

1. **æ»¡è¶³ç‰¹å®šéœ€æ±‚**ï¼šRPC è°ƒç”¨éœ€è¦ä¼ é€’æ–¹æ³•è°ƒç”¨çš„ç‰¹å®šä¿¡æ¯ï¼ˆå¦‚æœåŠ¡åã€æ–¹æ³•åã€å‚æ•°ç±»å‹ç­‰ï¼‰ï¼Œè¿™äº›ä¿¡æ¯éœ€è¦æœ‰ä¸“é—¨çš„æ•°æ®ç»“æ„æ¥æ‰¿è½½ã€‚

2. **ç®€åŒ–å®ç°**ï¼šåŸºäº HTTP åè®®æ„å»ºè‡ªå®šä¹‰åè®®ï¼Œå¯ä»¥åˆ©ç”¨ HTTP çš„æˆç†ŸåŸºç¡€è®¾æ–½ï¼Œé¿å…ä»åº•å±‚ TCP/IP å¼€å§‹å®ç°ï¼ŒåŒæ—¶ä¿æŒè‰¯å¥½çš„å¯è°ƒè¯•æ€§ã€‚

3. **çµæ´»æ€§ä¸å¯æ‰©å±•æ€§**ï¼š
   - å¯ä»¥æ ¹æ®éœ€è¦è‡ªå®šä¹‰åºåˆ—åŒ–æ–¹å¼ï¼ˆç›®å‰ä½¿ç”¨ JDK åºåˆ—åŒ–ï¼Œæœªæ¥å¯æ‰©å±•æ”¯æŒ JSONã€Protobuf ç­‰ï¼‰
   - å¯ä»¥æ‰©å±•åè®®å­—æ®µï¼Œæ”¯æŒé¢å¤–åŠŸèƒ½ï¼ˆå¦‚è¶…æ—¶æ§åˆ¶ã€æœåŠ¡ç‰ˆæœ¬ç­‰ï¼‰

4. **å°è£…å®ç°ç»†èŠ‚**ï¼šè‡ªå®šä¹‰åè®®å…è®¸åœ¨ä¸å½±å“è°ƒç”¨æ–¹çš„æƒ…å†µä¸‹ä¼˜åŒ–åº•å±‚å®ç°ï¼Œå¯¹ RPC æ¡†æ¶çš„ä½¿ç”¨è€…ä¿æŒé€æ˜ã€‚

### åè®®çš„ä¼˜åŠ¿

1. **æ˜“äºç†è§£å’Œè°ƒè¯•**ï¼šåŸºäº HTTP çš„åè®®ç›¸æ¯”çº¯ TCP åè®®æ›´æ˜“äºè°ƒè¯•ï¼Œå¯ä»¥ä½¿ç”¨å¸¸è§çš„ HTTP å·¥å…·è¿›è¡Œæµ‹è¯•ã€‚

2. **å¹¿æ³›çš„å…¼å®¹æ€§**ï¼šHTTP åè®®è¢«å¹¿æ³›æ”¯æŒï¼Œå‡ ä¹æ‰€æœ‰ç¼–ç¨‹è¯­è¨€å’Œå¹³å°éƒ½èƒ½å¤„ç† HTTP è¯·æ±‚ï¼Œä¸ºè·¨è¯­è¨€ã€è·¨å¹³å°è°ƒç”¨æä¾›äº†å¯èƒ½ã€‚

3. **æ— éœ€å¤„ç†ä½çº§ç½‘ç»œé—®é¢˜**ï¼šåˆ©ç”¨ HTTP åè®®å’Œ Vert.x æ¡†æ¶ï¼Œé¿å…äº†æ‰‹åŠ¨å¤„ç† TCP è¿æ¥ç®¡ç†ã€ç²˜åŒ…åŠåŒ…ç­‰å¤æ‚é—®é¢˜ã€‚

## ä»€ä¹ˆæ˜¯ TCP åè®®çš„åŠåŒ…ç²˜åŒ…é—®é¢˜ï¼Ÿä½ åœ¨é¡¹ç›®ä¸­æ˜¯å¦‚ä½•è§£å†³è¯¥é—®é¢˜çš„ï¼Ÿ

### TCP åŠåŒ…ç²˜åŒ…é—®é¢˜è§£æ

**åŠåŒ…ï¼ˆIncomplete Packetï¼‰**ï¼š
- å®šä¹‰ï¼šæ¥æ”¶æ–¹ä¸€æ¬¡è¯»å–åˆ°çš„æ•°æ®å°‘äºå‘é€æ–¹ä¸€æ¬¡å‘é€çš„æ•°æ®
- åŸå› ï¼šTCP ç¼“å†²åŒºå¤§å°é™åˆ¶ã€ç½‘ç»œå¸¦å®½é™åˆ¶ç­‰

**ç²˜åŒ…ï¼ˆSticky Packetï¼‰**ï¼š
- å®šä¹‰ï¼šæ¥æ”¶æ–¹ä¸€æ¬¡è¯»å–åˆ°çš„æ•°æ®åŒ…å«å‘é€æ–¹å¤šæ¬¡å‘é€çš„æ•°æ®
- åŸå› ï¼šTCP æ˜¯é¢å‘æµçš„åè®®ï¼Œæ²¡æœ‰æ¶ˆæ¯è¾¹ç•Œï¼›Nagle ç®—æ³•å¯èƒ½åˆå¹¶å°æ•°æ®åŒ…

```mermaid
graph TD
    A[å‘é€æ–¹] -->|æ•°æ®åŒ…1| B[TCP ä¼ è¾“å±‚]
    A -->|æ•°æ®åŒ…2| B
    B -->|"æ•°æ®åŒ…1+2ï¼ˆç²˜åŒ…ï¼‰"| C[æ¥æ”¶æ–¹]
    
    D[å‘é€æ–¹] -->|å¤§æ•°æ®åŒ…| E[TCP ä¼ è¾“å±‚]
    E -->|"éƒ¨åˆ†æ•°æ®ï¼ˆåŠåŒ…ï¼‰"| F[æ¥æ”¶æ–¹]
```

### æœ¬ RPC æ¡†æ¶çš„è§£å†³æ–¹æ¡ˆ

æœ¬é¡¹ç›®é€šè¿‡ä½¿ç”¨ HTTP åè®®å’Œ Vert.x æ¡†æ¶å·§å¦™åœ°é¿å¼€äº† TCP ç²˜åŒ…åŠåŒ…é—®é¢˜ï¼š

1. **åˆ©ç”¨ HTTP åè®®ç‰¹æ€§**ï¼š
   - HTTP åè®®æ˜¯åº”ç”¨å±‚åè®®ï¼Œæœ‰æ˜ç¡®çš„æ¶ˆæ¯è¾¹ç•Œ
   - HTTP å¤´éƒ¨åŒ…å« Content-Length æˆ–ä½¿ç”¨åˆ†å—ä¼ è¾“ç¼–ç ï¼Œæ˜ç¡®æŒ‡ç¤ºæ¶ˆæ¯ä½“å¤§å°

2. **Vert.x çš„å¤„ç†æœºåˆ¶**ï¼š
   - æœåŠ¡ç«¯ä½¿ç”¨ `request.bodyHandler()` ç¡®ä¿å®Œæ•´æ¥æ”¶è¯·æ±‚ä½“åå†å¤„ç†
   ```java
   request.bodyHandler(body -> {
       byte[] bytes = body.getBytes();
       RpcRequest rpcRequest = serializer.deserialize(bytes, RpcRequest.class);
       // å¤„ç†è¯·æ±‚...
   });
   ```
   
   - å®¢æˆ·ç«¯ä½¿ç”¨ WebClient å‘é€è¯·æ±‚å¹¶ç­‰å¾…å®Œæ•´å“åº”
   ```java
   webClient.request(HttpMethod.POST, port, host, "/")
           .sendBuffer(Buffer.buffer(requestBytes), ar -> {
               // å¤„ç†å“åº”...
           });
   ```

3. **å®Œæ•´æ€§ä¿è¯**ï¼š
   - Vert.x çš„ HTTP å®ç°è‡ªåŠ¨å¤„ç†äº† HTTP æ¶ˆæ¯çš„è§£æå’Œç»„è£…
   - åº”ç”¨å±‚åªéœ€å¤„ç†å®Œæ•´çš„ HTTP è¯·æ±‚å’Œå“åº”

é€šè¿‡è¿™ç§è®¾è®¡ï¼ŒRPC æ¡†æ¶é¿å…äº†ç›´æ¥å¤„ç† TCP åè®®çš„å¤æ‚æ€§ï¼Œåˆ©ç”¨ HTTP åè®®å’Œ Vert.x æ¡†æ¶æä¾›çš„æŠ½è±¡ï¼Œç®€åŒ–äº†å®ç°å¹¶æé«˜äº†å¯é æ€§ã€‚

## ä½ æ˜¯å¦‚ä½•å®ç°é¡¹ç›®ä¸­çš„ç½‘ç»œé€šä¿¡çš„ï¼Ÿä¸ºä»€ä¹ˆé€‰æ‹©äº† Vert.x æ¡†æ¶ï¼Ÿ

### ç½‘ç»œé€šä¿¡å®ç°æ–¹å¼

æœ¬é¡¹ç›®ä½¿ç”¨ Vert.x æ¡†æ¶å®ç°äº†åŸºäº HTTP çš„ RPC é€šä¿¡ï¼š

**æœåŠ¡ç«¯å®ç°**ï¼š
```java
// åˆ›å»º Vertx å®ä¾‹
Vertx vertx = Vertx.vertx();
// åˆ›å»º HTTP æœåŠ¡å™¨
io.vertx.core.http.HttpServer server = vertx.createHttpServer();
// è®¾ç½®è¯·æ±‚å¤„ç†å™¨
server.requestHandler(new HttpServerHandler());
// ç›‘å¬æŒ‡å®šç«¯å£
server.listen(port, result -> {
    if (result.succeeded()) {
        System.out.println("Server is now listening on port " + port);
    } else {
        System.out.println("Failed to start server: " + result.cause());
    }
});
```

**å®¢æˆ·ç«¯å®ç°**ï¼š
```java
// åˆ›å»º WebClient
WebClient webClient = WebClient.create(vertx, options);
// å‘é€ RPC è¯·æ±‚
webClient.request(HttpMethod.POST, port, host, "/")
        .sendBuffer(Buffer.buffer(requestBytes), ar -> {
            // å¤„ç†å“åº”
        });
```

### ä¸ºä»€ä¹ˆé€‰æ‹© Vert.x æ¡†æ¶ï¼Ÿ

1. **é«˜æ€§èƒ½çš„å¼‚æ­¥éé˜»å¡æ¨¡å‹**ï¼š
   - Vert.x åŸºäºäº‹ä»¶å¾ªç¯æ¨¡å‹ï¼Œé‡‡ç”¨éé˜»å¡ I/O
   - èƒ½é«˜æ•ˆå¤„ç†å¤§é‡å¹¶å‘è¿æ¥ï¼Œé€‚åˆ RPC æ¡†æ¶çš„é«˜å¹¶å‘åœºæ™¯
   - å•ä¸ªäº‹ä»¶å¾ªç¯çº¿ç¨‹å¯ä»¥å¤„ç†å¤šä¸ªè¿æ¥ï¼Œå‡å°‘èµ„æºæ¶ˆè€—

2. **ç®€æ´æ˜“ç”¨çš„ API**ï¼š
   - æä¾›äº†ç›´è§‚çš„ APIï¼Œå¦‚ `vertx.createHttpServer()`ã€`server.requestHandler()`
   - å¼‚æ­¥æ“ä½œä½¿ç”¨å›è°ƒã€Promise æˆ– Future æ¨¡å¼ï¼Œä»£ç æ¸…æ™°å¯è¯»
   - é™ä½äº†ç½‘ç»œç¼–ç¨‹çš„å¤æ‚åº¦

```mermaid
graph TD
    A[å®¢æˆ·ç«¯è¯·æ±‚] -->|å¼‚æ­¥å¤„ç†| B[Vert.x äº‹ä»¶å¾ªç¯]
    B -->|éé˜»å¡I/O| C[å¤„ç†è¯·æ±‚]
    C -->|å›è°ƒ| D[å“åº”å®¢æˆ·ç«¯]
    
    E[å¦ä¸€å®¢æˆ·ç«¯è¯·æ±‚] -->|åŒä¸€äº‹ä»¶å¾ªç¯å¤„ç†| B
```

3. **æ¨¡å—åŒ–å’Œå¯æ‰©å±•æ€§**ï¼š
   - Vert.x æä¾›ä¸°å¯Œçš„æ¨¡å—ï¼Œå¦‚ Webã€WebClientã€Config ç­‰
   - æ”¯æŒå¤šç§åè®®ï¼ˆHTTP/1.xã€HTTP/2ã€WebSocket ç­‰ï¼‰
   - ä¾¿äºæœªæ¥æ‰©å±• RPC æ¡†æ¶åŠŸèƒ½

4. **è½»é‡çº§**ï¼š
   - å¯åŠ¨å¿«é€Ÿï¼Œèµ„æºå ç”¨å°‘
   - é€‚åˆå¾®æœåŠ¡æ¶æ„ï¼Œæ— éœ€é‡é‡çº§åº”ç”¨æœåŠ¡å™¨

5. **å¯é æ€§**ï¼š
   - æˆç†Ÿçš„æ¡†æ¶ï¼Œç¤¾åŒºæ´»è·ƒï¼Œæ–‡æ¡£å®Œå–„
   - åœ¨ç”Ÿäº§ç¯å¢ƒä¸­è¢«å¹¿æ³›ä½¿ç”¨å’ŒéªŒè¯

## ğŸš€ Ming RPC Frameworkç½‘ç»œé€šä¿¡å®ç°

### HTTPé€šä¿¡å®ç°

#### HTTPæœåŠ¡å™¨
**æ–‡ä»¶è·¯å¾„**: `rpc-core/src/main/java/com/ming/rpc/server/http/VertxHttpServer.java`

```java
public class VertxHttpServer implements HttpServer {
    public void doStart(int port) {
        // åˆ›å»ºVertxå®ä¾‹
        Vertx vertx = Vertx.vertx();

        // åˆ›å»ºHTTPæœåŠ¡å™¨
        io.vertx.core.http.HttpServer server = vertx.createHttpServer();

        // å¤„ç†è¯·æ±‚
        server.requestHandler(new HttpServerHandler());

        // å¯åŠ¨HTTPæœåŠ¡å™¨å¹¶ç›‘å¬ç«¯å£
        server.listen(port, "0.0.0.0", result -> {
            if (result.succeeded()) {
                System.out.println("Vertx HTTP Server started on port " + port);
            } else {
                System.err.println("Failed to start Vertx HTTP Server: " + result.cause().getMessage());
            }
        });
    }
}
```

#### HTTPè¯·æ±‚å¤„ç†å™¨
**æ–‡ä»¶è·¯å¾„**: `rpc-core/src/main/java/com/ming/rpc/server/http/HttpServerHandler.java`

```java
public class HttpServerHandler implements Handler<HttpServerRequest> {
    @Override
    public void handle(HttpServerRequest request) {
        // æŒ‡å®šåºåˆ—åŒ–å™¨
        final Serializer serializer = SerializerFactory.getInstance(RpcApplication.getRpcConfig().getSerializer());

        // å¼‚æ­¥å¤„ç†HTTPè¯·æ±‚
        request.bodyHandler(body -> {
            byte[] bytes = body.getBytes();
            RpcRequest rpcRequest = null;
            try {
                rpcRequest = serializer.deserialize(bytes, RpcRequest.class);
            } catch (Exception e) {
                e.printStackTrace();
                request.response().setStatusCode(500).end("Internal Server Error");
                return;
            }

            // æ„é€ å“åº”ç»“æœå¯¹è±¡
            RpcResponse rpcResponse = new RpcResponse();
            if (rpcRequest == null) {
                rpcResponse.setMessage("Request is null");
                doResponse(request, rpcResponse, serializer);
                return;
            }

            try {
                // è·å–è¦è°ƒç”¨çš„æœåŠ¡å®ç°ç±»ï¼Œé€šè¿‡åå°„è°ƒç”¨
                Class<?> implClass = LocalRegistry.get(rpcRequest.getServiceName());
                Method method = implClass.getMethod(rpcRequest.getMethodName(), rpcRequest.getParameterTypes());
                Object result = method.invoke(implClass.newInstance(), rpcRequest.getArgs());

                // å°è£…è¿”å›ç»“æœ
                rpcResponse.setData(result);
                rpcResponse.setDataType(method.getReturnType());
                rpcResponse.setMessage("ok");
                rpcResponse.setMessageType(RpcResponse.MessageType.SUCCESS);
            } catch (Exception e) {
                e.printStackTrace();
                rpcResponse.setMessage("Internal Server Error");
                rpcResponse.setMessageType(RpcResponse.MessageType.FAILURE);
            }

            // å“åº”
            doResponse(request, rpcResponse, serializer);
        });
    }
}
```

### TCPé€šä¿¡å®ç°

#### TCPæœåŠ¡å™¨
**æ–‡ä»¶è·¯å¾„**: `rpc-core/src/main/java/com/ming/rpc/server/tcp/VertexTcpServer.java`

```java
@Slf4j
public class VertexTcpServer {
    public void doStart(int port) {
        // åˆ›å»º Vert.x å®ä¾‹
        Vertx vertx = Vertx.vertx();

        // åˆ›å»º TCP æœåŠ¡ç«¯
        NetServer netServer = vertx.createNetServer();

        // è®¾ç½® TCP æœåŠ¡ç«¯ç›‘å¬ç«¯å£
        netServer.connectHandler(new TcpServerHandler());

        // å¯åŠ¨ TCP æœåŠ¡ç«¯
        netServer.listen(port, ar -> {
            if (ar.succeeded()) {
                log.info("TCP æœåŠ¡ç«¯å¯åŠ¨æˆåŠŸï¼Œç›‘å¬ç«¯å£ï¼š{}", port);
            } else {
                log.error("TCP æœåŠ¡ç«¯å¯åŠ¨å¤±è´¥ï¼Œç›‘å¬ç«¯å£ï¼š{}", port, ar.cause());
            }
        });
    }
}
```

#### TCPå®¢æˆ·ç«¯
**æ–‡ä»¶è·¯å¾„**: `rpc-core/src/main/java/com/ming/rpc/server/tcp/VertexTcpClient.java`

```java
public class VertexTcpClient {
    public static RpcResponse doRequest(RpcRequest rpcRequest, ServiceMetaInfo serviceMetaInfo)
            throws InterruptedException, ExecutionException {
        // å‘é€ TCP è¯·æ±‚
        Vertx vertx = Vertx.vertx();
        NetClient netClient = vertx.createNetClient();
        CompletableFuture<RpcResponse> responseFuture = new CompletableFuture<>();

        netClient.connect(serviceMetaInfo.getServicePort(), serviceMetaInfo.getServiceHost(), result -> {
            if (result.succeeded()) {
                NetSocket socket = result.result();

                // å‘é€æ•°æ®
                ProtocolMessage.Header header = new ProtocolMessage.Header();
                header.setMagic(ProtocolConstant.PROTOCOL_MAGIC);
                header.setVersion(ProtocolConstant.PROTOCOL_VERSION);
                header.setSerializer((byte) ProtocolMessageSerializerEnum.getEnumByValue(RpcApplication.getRpcConfig().getSerializer()).getKey());
                header.setType((byte) ProtocolMessageTypeEnum.REQUEST.getKey());
                header.setRequestId(IdUtil.getSnowflakeNextId());

                ProtocolMessage<RpcRequest> protocolMessage = new ProtocolMessage<>(header, rpcRequest);
                try {
                    Buffer encodeBuffer = ProtocolMessageEncoder.encode(protocolMessage);
                    socket.write(encodeBuffer);
                } catch (Exception e) {
                    throw new RuntimeException("åè®®æ¶ˆæ¯ç¼–ç é”™è¯¯", e);
                }

                // æ¥æ”¶å“åº”
                TcpBufferHandlerWrapper bufferHandlerWrapper = new TcpBufferHandlerWrapper(buffer -> {
                    try {
                        ProtocolMessage<RpcResponse> rpcResponseProtocolMessage =
                            (ProtocolMessage<RpcResponse>) ProtocolMessageDecoder.decode(buffer);
                        responseFuture.complete(rpcResponseProtocolMessage.getBody());
                    } catch (Exception e) {
                        throw new RuntimeException("åè®®æ¶ˆæ¯è§£ç é”™è¯¯", e);
                    }
                });
                socket.handler(bufferHandlerWrapper);
            } else {
                System.err.println("Failed to connect to TCP server");
            }
        });

        RpcResponse rpcResponse = responseFuture.get();
        netClient.close();
        return rpcResponse;
    }
}
```

## ğŸ“Š åè®®å¯¹æ¯”

åŸºäºé¡¹ç›®å®é™…å®ç°çš„åè®®å¯¹æ¯”ï¼š

| åè®® | æ€§èƒ½ | è°ƒè¯•éš¾åº¦ | å®ç°å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|------|---------|-----------|----------|
| HTTP | ä¸­ç­‰ | ç®€å• | ä½ | å¼€å‘æµ‹è¯•ã€Webé›†æˆ |
| TCP | é«˜ | å›°éš¾ | é«˜ | ç”Ÿäº§ç¯å¢ƒã€é«˜æ€§èƒ½ |

## ğŸ”§ ä½¿ç”¨æŒ‡å—

### é…ç½®ç½‘ç»œåè®®
åœ¨RPCé…ç½®ä¸­æŒ‡å®šä½¿ç”¨çš„åè®®ï¼š

```yaml
rpc:
  serverHost: localhost
  serverPort: 8080
  # å…¶ä»–é…ç½®...
```

### å¯åŠ¨HTTPæœåŠ¡å™¨
```java
// å¯åŠ¨HTTPæœåŠ¡å™¨
HttpServer httpServer = new VertxHttpServer();
httpServer.doStart(8080);
```

### å¯åŠ¨TCPæœåŠ¡å™¨
```java
// å¯åŠ¨TCPæœåŠ¡å™¨
VertexTcpServer tcpServer = new VertexTcpServer();
tcpServer.doStart(8888);
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. åè®®é€‰æ‹©
- **å¼€å‘ç¯å¢ƒ**: ä½¿ç”¨HTTPåè®®ï¼Œä¾¿äºè°ƒè¯•å’Œæµ‹è¯•
- **ç”Ÿäº§ç¯å¢ƒ**: ä½¿ç”¨TCPåè®®ï¼Œè·å¾—æ›´å¥½çš„æ€§èƒ½
- **æ··åˆéƒ¨ç½²**: åŒæ—¶æ”¯æŒHTTPå’ŒTCPï¼Œæ»¡è¶³ä¸åŒéœ€æ±‚

### 2. æ€§èƒ½ä¼˜åŒ–
- ä½¿ç”¨è¿æ¥æ± ç®¡ç†ç½‘ç»œè¿æ¥
- å¯ç”¨Keep-Aliveå‡å°‘è¿æ¥å¼€é”€
- åˆç†è®¾ç½®è¶…æ—¶æ—¶é—´

### 3. é”™è¯¯å¤„ç†
- å®ç°å®Œå–„çš„å¼‚å¸¸å¤„ç†æœºåˆ¶
- æä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
- æ”¯æŒä¼˜é›…çš„æœåŠ¡é™çº§

### 4. ç›‘æ§å’Œè°ƒè¯•
- è®°å½•ç½‘ç»œé€šä¿¡æ—¥å¿—
- ç›‘æ§è¿æ¥æ•°å’Œå“åº”æ—¶é—´
- æä¾›è°ƒè¯•å·¥å…·å’Œæ¥å£

## ğŸ“‹ æ€»ç»“

Ming RPC Frameworké€šè¿‡ç²¾å¿ƒè®¾è®¡çš„åè®®å’Œç½‘ç»œé€šä¿¡æ¶æ„ï¼Œæä¾›äº†é«˜æ•ˆã€å¯é çš„åˆ†å¸ƒå¼é€šä¿¡è§£å†³æ–¹æ¡ˆï¼š

### æ ¸å¿ƒä¼˜åŠ¿
- âœ… **å¤šåè®®æ”¯æŒ**: HTTPå’ŒTCPä¸¤ç§åè®®ï¼Œæ»¡è¶³ä¸åŒåœºæ™¯éœ€æ±‚
- âœ… **é«˜æ€§èƒ½**: åŸºäºVert.xçš„å¼‚æ­¥éé˜»å¡æ¶æ„ï¼Œæ”¯æŒé«˜å¹¶å‘
- âœ… **æ˜“è°ƒè¯•**: HTTPåè®®ä¾¿äºå¼€å‘å’Œè°ƒè¯•
- âœ… **å¯æ‰©å±•**: æ”¯æŒè‡ªå®šä¹‰åè®®å’Œç¼–è§£ç å™¨

### æŠ€æœ¯ç‰¹è‰²
- **å¼‚æ­¥éé˜»å¡**: åŸºäºVert.xäº‹ä»¶å¾ªç¯æ¨¡å‹ï¼Œé«˜æ•ˆå¤„ç†å¹¶å‘
- **åè®®ç¼–è§£ç **: å®Œæ•´çš„åè®®æ¶ˆæ¯ç¼–è§£ç æœºåˆ¶
- **åŠåŒ…ç²˜åŒ…å¤„ç†**: TCPåè®®çš„å®Œæ•´æ¶ˆæ¯è¾¹ç•Œå¤„ç†
- **é”™è¯¯å¤„ç†**: å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œé”™è¯¯æ¢å¤æœºåˆ¶

Ming RPC Frameworkçš„åè®®ä¸ç½‘ç»œé€šä¿¡ä¸ºåˆ†å¸ƒå¼RPCè°ƒç”¨æä¾›äº†å¼ºæœ‰åŠ›çš„åŸºç¡€è®¾æ–½æ”¯æ’‘ï¼Œç¡®ä¿äº†æœåŠ¡é—´é€šä¿¡çš„é«˜æ•ˆæ€§å’Œå¯é æ€§ã€‚