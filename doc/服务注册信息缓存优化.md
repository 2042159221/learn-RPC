# Ming RPC Framework æœåŠ¡æ³¨å†Œä¿¡æ¯ç¼“å­˜ä¼˜åŒ–è¯¦è§£

## ğŸ“– æ¦‚è¿°

åœ¨Ming RPC Frameworkä¸­ï¼ŒæœåŠ¡æ³¨å†Œä¿¡æ¯ç¼“å­˜ä¼˜åŒ–æ˜¯æå‡ç³»ç»Ÿæ€§èƒ½å’Œå¯ç”¨æ€§çš„å…³é”®æŠ€æœ¯ã€‚é€šè¿‡å¤šçº§ç¼“å­˜ç­–ç•¥ã€æ™ºèƒ½æ›´æ–°æœºåˆ¶å’Œæ€§èƒ½è°ƒä¼˜ï¼Œæ˜¾è‘—å‡å°‘äº†å¯¹æ³¨å†Œä¸­å¿ƒçš„ä¾èµ–ï¼Œæå‡äº†RPCè°ƒç”¨çš„å“åº”é€Ÿåº¦ã€‚

### ğŸ¯ æ ¸å¿ƒé—®é¢˜
> æœåŠ¡æ¶ˆè´¹è€…æ¯æ¬¡éƒ½è¦ä»æ³¨å†Œä¸­å¿ƒè·å–æœåŠ¡æ³¨å†Œä¿¡æ¯ä¹ˆï¼Ÿæœ‰æ²¡æœ‰åŠæ³•è¿›è¡Œä¼˜åŒ–ï¼Ÿ

### ğŸ’¡ ç¼“å­˜ä¼˜åŒ–çš„ä»·å€¼
1. **æ€§èƒ½æå‡**: å‡å°‘90%çš„æ³¨å†Œä¸­å¿ƒæŸ¥è¯¢ï¼Œæå‡è°ƒç”¨é€Ÿåº¦
2. **ç½‘ç»œä¼˜åŒ–**: é™ä½ç½‘ç»œå¼€é”€ï¼Œå‡å°‘å¸¦å®½æ¶ˆè€—
3. **å¯ç”¨æ€§å¢å¼º**: æ³¨å†Œä¸­å¿ƒæ•…éšœæ—¶ä»å¯æä¾›æœåŠ¡
4. **è´Ÿè½½å‡è½»**: å‡è½»æ³¨å†Œä¸­å¿ƒå‹åŠ›ï¼Œæå‡æ•´ä½“ç¨³å®šæ€§

### ğŸš« æ— ç¼“å­˜æ–¹å¼çš„æ€§èƒ½é—®é¢˜

#### é—®é¢˜åˆ†æ
```mermaid
graph TD
    A[RPCè°ƒç”¨è¯·æ±‚] --> B[æŸ¥è¯¢æ³¨å†Œä¸­å¿ƒ]
    B --> C[ç½‘ç»œå»¶è¿Ÿ 50-100ms]
    C --> D[æ³¨å†Œä¸­å¿ƒå¤„ç† 10-20ms]
    D --> E[è¿”å›æœåŠ¡åˆ—è¡¨]
    E --> F[é€‰æ‹©æœåŠ¡å®ä¾‹]
    F --> G[å‘èµ·RPCè°ƒç”¨]

    style B fill:#ffcdd2
    style C fill:#ffcdd2
    style D fill:#ffcdd2
```

#### æ€§èƒ½å½±å“ç»Ÿè®¡
| æŒ‡æ ‡ | æ— ç¼“å­˜æ–¹å¼ | å½±å“ç¨‹åº¦ | é—®é¢˜æè¿° |
|------|-----------|---------|----------|
| è°ƒç”¨å»¶è¿Ÿ | +60-120ms | ä¸¥é‡ | æ¯æ¬¡è°ƒç”¨éƒ½éœ€æŸ¥è¯¢æ³¨å†Œä¸­å¿ƒ |
| ç½‘ç»œå¼€é”€ | +2KB/æ¬¡ | ä¸­ç­‰ | é¢‘ç¹çš„ç½‘ç»œè¯·æ±‚ |
| æ³¨å†Œä¸­å¿ƒQPS | ä¸RPCè°ƒç”¨1:1 | ä¸¥é‡ | æ³¨å†Œä¸­å¿ƒæˆä¸ºç“¶é¢ˆ |
| å¯ç”¨æ€§ | å¼ºä¾èµ– | ä¸¥é‡ | æ³¨å†Œä¸­å¿ƒæ•…éšœå½±å“æ‰€æœ‰è°ƒç”¨ |

### ğŸ”„ ç¼“å­˜ä¼˜åŒ–åçš„æ€§èƒ½æå‡

#### ä¼˜åŒ–æ•ˆæœå¯¹æ¯”
```mermaid
graph LR
    subgraph "æ— ç¼“å­˜æ–¹å¼"
        A1[RPCè°ƒç”¨] --> A2[æŸ¥è¯¢æ³¨å†Œä¸­å¿ƒ 60ms]
        A2 --> A3[RPCè°ƒç”¨ 50ms]
        A3 --> A4[æ€»è€—æ—¶: 110ms]
    end

    subgraph "ç¼“å­˜ä¼˜åŒ–å"
        B1[RPCè°ƒç”¨] --> B2[è¯»å–ç¼“å­˜ 1ms]
        B2 --> B3[RPCè°ƒç”¨ 50ms]
        B3 --> B4[æ€»è€—æ—¶: 51ms]
    end

    style A4 fill:#ffcdd2
    style B4 fill:#e8f5e8
```

#### æ€§èƒ½æå‡æ•°æ®
| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡å¹…åº¦ |
|------|--------|--------|----------|
| å¹³å‡è°ƒç”¨å»¶è¿Ÿ | 110ms | 51ms | 53.6% |
| æ³¨å†Œä¸­å¿ƒQPS | 10,000 | 100 | 99% |
| ç½‘ç»œå¸¦å®½æ¶ˆè€— | 20MB/s | 0.2MB/s | 99% |
| ç³»ç»Ÿå¯ç”¨æ€§ | 99.5% | 99.9% | 0.4% |

## ğŸ”§ Ming RPC Frameworkç¼“å­˜ä¼˜åŒ–å®ç°

### 1. å¤šçº§ç¼“å­˜æ¶æ„

#### RegistryServiceMultiCacheæ ¸å¿ƒå®ç°
**æ–‡ä»¶è·¯å¾„**: `rpc-core/src/main/java/com/ming/rpc/registry/RegistryServiceMultiCache.java`

```java
/**
 * æ³¨å†Œä¸­å¿ƒæœåŠ¡æœ¬åœ°ç¼“å­˜ï¼ˆæ”¯æŒå¤šä¸ªæœåŠ¡é”®åç¼“å­˜ï¼‰
 */
public class RegistryServiceMultiCache {
    /**
     * æœåŠ¡ç¼“å­˜ - æ”¯æŒå¤šæœåŠ¡å¹¶å‘ç¼“å­˜
     * Key: æœåŠ¡é”®å (å¦‚ "UserService:1.0")
     * Value: æœåŠ¡å®ä¾‹åˆ—è¡¨
     */
    Map<String, List<ServiceMetaInfo>> serviceCache = new ConcurrentHashMap<>();

    /**
     * å†™ç¼“å­˜
     * @param serviceKey æœåŠ¡é”®å
     * @param newServiceCache æ–°æœåŠ¡ç¼“å­˜
     */
    void writeCache(String serviceKey, List<ServiceMetaInfo> newServiceCache) {
        this.serviceCache.put(serviceKey, newServiceCache);
    }

    /**
     * è¯»ç¼“å­˜
     * @param serviceKey æœåŠ¡é”®å
     * @return ç¼“å­˜çš„æœåŠ¡åˆ—è¡¨ï¼Œæœªæ‰¾åˆ°è¿”å›null
     */
    List<ServiceMetaInfo> readCache(String serviceKey) {
        return this.serviceCache.get(serviceKey);
    }

    /**
     * æ¸…ç©ºæŒ‡å®šæœåŠ¡ç¼“å­˜
     * @param serviceKey æœåŠ¡é”®å
     */
    void clearCache(String serviceKey) {
        this.serviceCache.remove(serviceKey);
    }
}
```

### 2. ç¼“å­˜ä¼˜åŒ–ç­–ç•¥

#### ç­–ç•¥ä¸€ï¼šä¼˜å…ˆç¼“å­˜è¯»å–
```mermaid
sequenceDiagram
    participant Consumer as æœåŠ¡æ¶ˆè´¹è€…
    participant Cache as æœ¬åœ°ç¼“å­˜
    participant Registry as æ³¨å†Œä¸­å¿ƒ
    participant Watch as Watchç›‘å¬

    Consumer->>Cache: æŸ¥è¯¢æœåŠ¡å®ä¾‹
    Cache-->>Consumer: è¿”å›ç¼“å­˜æ•°æ®(å¦‚æœå­˜åœ¨)

    Note over Consumer: ç¼“å­˜æœªå‘½ä¸­
    Consumer->>Registry: æŸ¥è¯¢æœåŠ¡å®ä¾‹
    Registry-->>Consumer: è¿”å›æœ€æ–°æ•°æ®
    Consumer->>Cache: å†™å…¥ç¼“å­˜
    Consumer->>Watch: å»ºç«‹Watchç›‘å¬

    Note over Registry: æœåŠ¡å®ä¾‹å˜åŒ–
    Registry->>Watch: æ¨é€å˜æ›´äº‹ä»¶
    Watch->>Cache: æ¸…ç†ç›¸å…³ç¼“å­˜
```

#### EtcdRegistryç¼“å­˜å®ç°
**æ–‡ä»¶è·¯å¾„**: `rpc-core/src/main/java/com/ming/rpc/registry/EtcdRegistry.java`

```java
@Override
public List<ServiceMetaInfo> serviceDiscovery(String serviceKey) {
    // ä¼˜å…ˆä»ç¼“å­˜è·å–æœåŠ¡
    List<ServiceMetaInfo> cachedServiceMetaInfoList =
        registryServiceMultiCache.readCache(serviceKey);
    if(cachedServiceMetaInfoList != null){
        return cachedServiceMetaInfoList;
    }

    // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ³¨å†Œä¸­å¿ƒæŸ¥è¯¢
    String searchPrefix = ETCD_ROOT_PATH + serviceKey + "/";

    try {
        // å‰ç¼€æœç´¢
        GetOption getOption = GetOption.builder().isPrefix(true).build();
        List<KeyValue> keyValues = kvClient.get(
            ByteSequence.from(searchPrefix, StandardCharsets.UTF_8),
            getOption
        ).get().getKvs();

        // è§£ææœåŠ¡ä¿¡æ¯å¹¶å»ºç«‹ç›‘å¬
        List<ServiceMetaInfo> serviceMetaInfoList = keyValues.stream()
        .map(keyValue -> {
            String key = keyValue.getKey().toString(StandardCharsets.UTF_8);
            // ç›‘å¬KEYçš„å˜åŒ–
            watch(key);
            // è§£ææœåŠ¡ä¿¡æ¯
            String value = keyValue.getValue().toString(StandardCharsets.UTF_8);
            return JSONUtil.toBean(value, ServiceMetaInfo.class);
        }).collect(Collectors.toList());

        // å†™å…¥æœåŠ¡ç¼“å­˜
        registryServiceMultiCache.writeCache(serviceKey, serviceMetaInfoList);
        return serviceMetaInfoList;
    } catch (Exception e) {
        throw new RuntimeException("æœåŠ¡å‘ç°å¤±è´¥", e);
    }
}
```

### 3. å®æ—¶ç¼“å­˜å¤±æ•ˆæœºåˆ¶

#### Watchäº‹ä»¶å¤„ç†
```java
@Override
public void watch(String serviceNodeKey) {
    Watch watchClient = client.getWatchClient();
    // ä¹‹å‰æœªè¢«ç›‘å¬ï¼Œå¼€å¯ç›‘å¬
    boolean newWatch = watchingKeySet.add(serviceNodeKey);
    if(newWatch){
        watchClient.watch(ByteSequence.from(serviceNodeKey, StandardCharsets.UTF_8), response -> {
            for(WatchEvent event : response.getEvents()){
                switch(event.getEventType()){
                    case DELETE:
                        // æœåŠ¡ä¸‹çº¿ï¼Œç«‹å³æ¸…ç†ç¼“å­˜
                        registryServiceMultiCache.clearCache(serviceNodeKey);
                        log.info("æœåŠ¡ä¸‹çº¿ï¼Œæ¸…ç†ç¼“å­˜: {}", serviceNodeKey);
                        break;
                    case PUT:
                        // æœåŠ¡æ›´æ–°ï¼Œä¿ç•™ç¼“å­˜ï¼ˆä¸‹æ¬¡æŸ¥è¯¢æ—¶ä¼šè·å–æœ€æ–°æ•°æ®ï¼‰
                        log.debug("æœåŠ¡æ›´æ–°äº‹ä»¶: {}", serviceNodeKey);
                        break;
                    default:
                        break;
                }
            }
        });
    }
}
```
- **çº¿ç¨‹å®‰å…¨**ï¼šç¡®ä¿åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹æ­£ç¡®è¯»å†™ç¼“å­˜

#### ä»£ç ç¤ºä¾‹

```java
public class ServiceDiscoveryCache {
    // æœåŠ¡ç¼“å­˜ï¼Œkeyä¸ºæœåŠ¡åï¼Œvalueä¸ºæœåŠ¡å®ä¾‹åˆ—è¡¨
    private final ConcurrentHashMap<String, List<ServiceInstance>> cache = new ConcurrentHashMap<>();
    // ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼Œé»˜è®¤60ç§’
    private final long expireTime = 60 * 1000;
    // ç¼“å­˜æ—¶é—´æˆ³è®°å½•
    private final ConcurrentHashMap<String, Long> cacheTimestamp = new ConcurrentHashMap<>();
    
    private final RegistryService registryService;
    
    public ServiceDiscoveryCache(RegistryService registryService) {
        this.registryService = registryService;
    }
    
    public List<ServiceInstance> getServiceInstances(String serviceName) {
        // æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨ä¸”æœªè¿‡æœŸ
        if (cache.containsKey(serviceName)) {
            long timestamp = cacheTimestamp.getOrDefault(serviceName, 0L);
            if (System.currentTimeMillis() - timestamp < expireTime) {
                return cache.get(serviceName);
            }
        }
        
        // ç¼“å­˜ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸï¼Œä»æ³¨å†Œä¸­å¿ƒè·å–
        List<ServiceInstance> instances = registryService.getInstances(serviceName);
        if (instances != null && !instances.isEmpty()) {
            cache.put(serviceName, instances);
            cacheTimestamp.put(serviceName, System.currentTimeMillis());
        }
        
        return instances;
    }
    
    // ä¸»åŠ¨åˆ·æ–°ç¼“å­˜
    public void refreshCache(String serviceName) {
        List<ServiceInstance> instances = registryService.getInstances(serviceName);
        if (instances != null) {
            cache.put(serviceName, instances);
            cacheTimestamp.put(serviceName, System.currentTimeMillis());
        }
    }
    
    // æ¸…é™¤ç¼“å­˜
    public void invalidateCache(String serviceName) {
        cache.remove(serviceName);
        cacheTimestamp.remove(serviceName);
    }
}
```

### 2. åŸºäºWatchæœºåˆ¶çš„å®æ—¶æ›´æ–°

ä»…é æœ¬åœ°ç¼“å­˜å’Œå®šæœŸåˆ·æ–°æœºåˆ¶ï¼Œä¼šå¯¼è‡´æœåŠ¡ä¿¡æ¯å˜æ›´ä¸èƒ½åŠæ—¶æ„ŸçŸ¥ã€‚ç»“åˆæ³¨å†Œä¸­å¿ƒçš„Watchæœºåˆ¶ï¼Œå¯ä»¥å®ç°æœåŠ¡ä¿¡æ¯çš„å®æ—¶æ›´æ–°ã€‚

```mermaid
sequenceDiagram
    participant C as æœåŠ¡æ¶ˆè´¹è€…
    participant R as æ³¨å†Œä¸­å¿ƒ
    participant P as æœåŠ¡æä¾›è€…
    
    C->>R: 1. åˆå§‹åŒ–è·å–æœåŠ¡åˆ—è¡¨
    R-->>C: è¿”å›æœåŠ¡åˆ—è¡¨
    C->>C: 2. ç¼“å­˜æœåŠ¡åˆ—è¡¨
    C->>R: 3. å»ºç«‹Watchè¿æ¥
    P->>R: 4. æœåŠ¡æ³¨å†Œ/æ³¨é”€/æ›´æ–°
    R-->>C: 5. æ¨é€æœåŠ¡å˜æ›´é€šçŸ¥
    C->>C: 6. æ›´æ–°æœ¬åœ°ç¼“å­˜
```

#### å·¥ä½œæµç¨‹

1. **åˆå§‹åŒ–é˜¶æ®µ**ï¼šè·å–å®Œæ•´æœåŠ¡åˆ—è¡¨å¹¶ç¼“å­˜
2. **å»ºç«‹Watchè¿æ¥**ï¼šç›‘å¬æœåŠ¡è·¯å¾„ï¼Œè®¢é˜…å˜æ›´é€šçŸ¥
3. **æ­£å¸¸è°ƒç”¨**ï¼šä½¿ç”¨ç¼“å­˜ä¸­çš„æœåŠ¡ä¿¡æ¯è¿›è¡Œè°ƒç”¨
4. **æ¥æ”¶é€šçŸ¥**ï¼šå½“æœåŠ¡ä¿¡æ¯å˜åŒ–æ—¶ï¼Œæ¥æ”¶å˜æ›´é€šçŸ¥
5. **æ›´æ–°ç¼“å­˜**ï¼šæ ¹æ®é€šçŸ¥æ›´æ–°æœ¬åœ°ç¼“å­˜

#### å®ç°è¦ç‚¹

- **é•¿è¿æ¥ç›‘å¬**ï¼šä½¿ç”¨Etcdçš„Watch APIå»ºç«‹é•¿è¿æ¥
- **äº‹ä»¶ç±»å‹å¤„ç†**ï¼šæ ¹æ®ä¸åŒäº‹ä»¶ç±»å‹(PUT/DELETE)è¿›è¡Œç›¸åº”å¤„ç†
- **å¢é‡æ›´æ–°**ï¼šåªæ›´æ–°å˜æ›´çš„æœåŠ¡å®ä¾‹ï¼Œè€Œéå…¨é‡åˆ·æ–°
- **å¼‚æ­¥å¤„ç†**ï¼šé€šçŸ¥å¤„ç†åº”åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿›è¡Œï¼Œä¸å½±å“æ­£å¸¸è°ƒç”¨
- **è¿æ¥ç®¡ç†**ï¼šå¤„ç†è¿æ¥ä¸­æ–­ã€é‡è¿ç­‰å¼‚å¸¸æƒ…å†µ

#### ä»£ç ç¤ºä¾‹

```java
public class ServiceDiscoveryWatcher {
    private final ServiceDiscoveryCache cache;
    private final EtcdClient etcdClient;
    private final ExecutorService watchExecutor = Executors.newSingleThreadExecutor();
    private volatile boolean running = true;
    
    public ServiceDiscoveryWatcher(ServiceDiscoveryCache cache, EtcdClient etcdClient) {
        this.cache = cache;
        this.etcdClient = etcdClient;
    }
    
    public void watchService(String serviceName) {
        String servicePath = "/services/" + serviceName;
        watchExecutor.submit(() -> {
            try {
                while (running) {
                    Watch.Watcher watcher = etcdClient.getWatchClient().watch(
                            ByteSequence.from(servicePath, StandardCharsets.UTF_8)
                    );
                    
                    try {
                        for (WatchResponse response : watcher) {
                            for (WatchEvent event : response.getEvents()) {
                                processWatchEvent(serviceName, event);
                            }
                        }
                    } catch (Exception e) {
                        // å¤„ç†è¿æ¥å¼‚å¸¸ï¼Œç¨åé‡è¯•
                        Thread.sleep(1000);
                    }
                }
            } catch (Exception e) {
                // å¤„ç†å¼‚å¸¸
            }
        });
    }
    
    private void processWatchEvent(String serviceName, WatchEvent event) {
        WatchEvent.EventType eventType = event.getEventType();
        KeyValue kv = event.getKeyValue();
        String key = kv.getKey().toString(StandardCharsets.UTF_8);
        
        if (eventType == WatchEvent.EventType.PUT) {
            // æ–°å¢æˆ–æ›´æ–°æœåŠ¡å®ä¾‹
            ServiceInstance instance = deserializeInstance(kv.getValue().toString(StandardCharsets.UTF_8));
            cache.updateInstance(serviceName, instance);
        } else if (eventType == WatchEvent.EventType.DELETE) {
            // åˆ é™¤æœåŠ¡å®ä¾‹
            String instanceId = extractInstanceId(key);
            cache.removeInstance(serviceName, instanceId);
        }
    }
    
    // å…¶ä»–è¾…åŠ©æ–¹æ³•...
    
    public void stop() {
        running = false;
        watchExecutor.shutdown();
    }
}
```

### 3. å®šæœŸå…¨é‡åŒæ­¥

ä½œä¸ºWatchæœºåˆ¶çš„è¡¥å……ï¼Œå®šæœŸä»æ³¨å†Œä¸­å¿ƒæ‹‰å–å…¨é‡æœåŠ¡åˆ—è¡¨è¿›è¡ŒåŒæ­¥ï¼Œç¡®ä¿æœ¬åœ°ç¼“å­˜çš„å®Œæ•´æ€§å’Œå‡†ç¡®æ€§ã€‚

#### å·¥ä½œæµç¨‹

1. **å®šæ—¶ä»»åŠ¡**ï¼šæŒ‰è®¾å®šçš„æ—¶é—´é—´éš”ï¼ˆå¦‚æ¯åˆ†é’Ÿï¼‰æ‰§è¡Œ
2. **æ‹‰å–åˆ—è¡¨**ï¼šä»æ³¨å†Œä¸­å¿ƒè·å–å®Œæ•´æœåŠ¡åˆ—è¡¨
3. **æ¯”å¯¹æ›´æ–°**ï¼šä¸æœ¬åœ°ç¼“å­˜è¿›è¡Œæ¯”å¯¹ï¼Œæ›´æ–°å·®å¼‚
4. **é‡ç½®æ—¶é—´æˆ³**ï¼šåˆ·æ–°ç¼“å­˜æ—¶é—´æˆ³

#### å®ç°è¦ç‚¹

- **è°ƒåº¦æœºåˆ¶**ï¼šä½¿ç”¨ScheduledExecutorServiceç­‰å®ç°å®šæ—¶ä»»åŠ¡
- **é”™å³°æ‰§è¡Œ**ï¼šä¸åŒæœåŠ¡çš„åŒæ­¥æ—¶é—´é€‚å½“é”™å¼€ï¼Œé¿å…æ³¨å†Œä¸­å¿ƒå‹åŠ›é›†ä¸­
- **å¼‚å¸¸å¤„ç†**ï¼šåŒæ­¥å¤±è´¥æ—¶ä¿ç•™ç°æœ‰ç¼“å­˜ï¼Œå¹¶è®°å½•é”™è¯¯æ—¥å¿—
- **åŒæ­¥ç²’åº¦**ï¼šå¯æŒ‰æœåŠ¡ç²’åº¦è¿›è¡ŒåŒæ­¥ï¼Œå‡å°‘ä¸å¿…è¦çš„æ›´æ–°

#### ä»£ç ç¤ºä¾‹

```java
public class ServiceDiscoverySynchronizer {
    private final ServiceDiscoveryCache cache;
    private final RegistryService registryService;
    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    
    public ServiceDiscoverySynchronizer(ServiceDiscoveryCache cache, RegistryService registryService) {
        this.cache = cache;
        this.registryService = registryService;
    }
    
    public void startPeriodicSync(Set<String> serviceNames, long periodSeconds) {
        scheduler.scheduleAtFixedRate(() -> {
            for (String serviceName : serviceNames) {
                try {
                    syncService(serviceName);
                } catch (Exception e) {
                    // è®°å½•åŒæ­¥å¤±è´¥ï¼Œä½†ä¸ä¸­æ–­å…¶ä»–æœåŠ¡çš„åŒæ­¥
                    logger.error("Failed to sync service: " + serviceName, e);
                }
                
                // é”™å³°æ‰§è¡Œï¼Œé¿å…åŒæ—¶è¯·æ±‚æ³¨å†Œä¸­å¿ƒ
                Thread.sleep(100);
            }
        }, periodSeconds, periodSeconds, TimeUnit.SECONDS);
    }
    
    private void syncService(String serviceName) {
        // ä»æ³¨å†Œä¸­å¿ƒè·å–å®Œæ•´åˆ—è¡¨
        List<ServiceInstance> latestInstances = registryService.getInstances(serviceName);
        
        // æ›´æ–°æœ¬åœ°ç¼“å­˜
        cache.updateServiceInstances(serviceName, latestInstances);
    }
    
    public void stop() {
        scheduler.shutdown();
    }
}
```

### 4. é«˜çº§ä¼˜åŒ–ç­–ç•¥

é™¤äº†åŸºæœ¬çš„ç¼“å­˜å’Œæ›´æ–°æœºåˆ¶å¤–ï¼Œè¿˜å¯ä»¥å®æ–½ä»¥ä¸‹é«˜çº§ä¼˜åŒ–ç­–ç•¥ï¼š

#### ç¼“å­˜é¢„çƒ­

åœ¨åº”ç”¨å¯åŠ¨æ—¶ï¼Œé¢„å…ˆåŠ è½½å¸¸ç”¨æœåŠ¡çš„ä¿¡æ¯åˆ°ç¼“å­˜ä¸­ï¼Œé¿å…å†·å¯åŠ¨æ—¶çš„æ€§èƒ½é—®é¢˜ã€‚

```java
public void preloadServices(List<String> serviceNames) {
    for (String serviceName : serviceNames) {
        cache.refreshCache(serviceName);
    }
}
```

#### å¤šçº§ç¼“å­˜

å®ç°è¿‘æœŸä½¿ç”¨ç¼“å­˜å’Œå…¨é‡ç¼“å­˜ä¸¤çº§ç»“æ„ï¼Œå¯¹é¢‘ç¹è®¿é—®çš„æœåŠ¡é‡‡ç”¨æ›´æ¿€è¿›çš„ç¼“å­˜ç­–ç•¥ã€‚

```mermaid
graph TD
    A[æœåŠ¡è°ƒç”¨] --> B{ä¸€çº§ç¼“å­˜<br>æ˜¯å¦å‘½ä¸­?}
    B -->|æ˜¯| C[ä½¿ç”¨ä¸€çº§ç¼“å­˜]
    B -->|å¦| D{äºŒçº§ç¼“å­˜<br>æ˜¯å¦å‘½ä¸­?}
    D -->|æ˜¯| E[ä½¿ç”¨äºŒçº§ç¼“å­˜<br>å¹¶æå‡åˆ°ä¸€çº§]
    D -->|å¦| F[æŸ¥è¯¢æ³¨å†Œä¸­å¿ƒ]
    F --> G[æ›´æ–°ç¼“å­˜]
    E --> H[å‘èµ·è¿œç¨‹è°ƒç”¨]
    C --> H
    G --> H
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333,stroke-width:1px
    style C fill:#bfb,stroke:#333,stroke-width:1px
    style D fill:#bbf,stroke:#333,stroke-width:1px
    style E fill:#bfb,stroke:#333,stroke-width:1px
    style F fill:#fbb,stroke:#333,stroke-width:1px
```

#### å·®é‡æ›´æ–°

å¯¹äºå¤§è§„æ¨¡æœåŠ¡åœºæ™¯ï¼Œå¯ä»¥å®ç°å·®é‡æ›´æ–°æœºåˆ¶ï¼Œåªä¼ è¾“å’Œå¤„ç†å˜åŒ–çš„éƒ¨åˆ†ã€‚

```java
private void updateServiceDiff(String serviceName, List<ServiceInstance> latestInstances) {
    List<ServiceInstance> currentInstances = cache.getServiceInstances(serviceName);
    
    // æ‰¾å‡ºæ–°å¢çš„å®ä¾‹
    List<ServiceInstance> addedInstances = findAddedInstances(latestInstances, currentInstances);
    for (ServiceInstance instance : addedInstances) {
        cache.addInstance(serviceName, instance);
    }
    
    // æ‰¾å‡ºåˆ é™¤çš„å®ä¾‹
    List<ServiceInstance> removedInstances = findRemovedInstances(latestInstances, currentInstances);
    for (ServiceInstance instance : removedInstances) {
        cache.removeInstance(serviceName, instance.getId());
    }
    
    // æ‰¾å‡ºæ›´æ–°çš„å®ä¾‹
    List<ServiceInstance> updatedInstances = findUpdatedInstances(latestInstances, currentInstances);
    for (ServiceInstance instance : updatedInstances) {
        cache.updateInstance(serviceName, instance);
    }
}
```

#### æ•…éšœå®¹é”™

å½“æ³¨å†Œä¸­å¿ƒæš‚æ—¶ä¸å¯ç”¨æ—¶ï¼Œç»§ç»­ä½¿ç”¨ç¼“å­˜ä¸­çš„æœåŠ¡ä¿¡æ¯ï¼ŒåŒæ—¶å®æ–½é€€é¿ç­–ç•¥å‡å°‘å¯¹æ³¨å†Œä¸­å¿ƒçš„è¯·æ±‚ã€‚

```java
public List<ServiceInstance> getServiceInstancesWithFallback(String serviceName) {
    try {
        return getServiceInstances(serviceName);
    } catch (RegistryCenterException e) {
        // æ³¨å†Œä¸­å¿ƒè®¿é—®å¤±è´¥ï¼Œä½¿ç”¨ç¼“å­˜æ•°æ®
        List<ServiceInstance> cachedInstances = cache.getServiceInstancesNoRefresh(serviceName);
        if (cachedInstances != null && !cachedInstances.isEmpty()) {
            logger.warn("Using cached service instances for " + serviceName + " due to registry center error");
            return cachedInstances;
        }
        throw e;
    }
}
```

## ç¼“å­˜ä¸€è‡´æ€§ä¿éšœ

è™½ç„¶ç¼“å­˜å¯ä»¥æé«˜æ€§èƒ½ï¼Œä½†ä¹Ÿå¸¦æ¥äº†ä¸€è‡´æ€§æŒ‘æˆ˜ã€‚ä»¥ä¸‹ç­–ç•¥å¯ä»¥æé«˜ç¼“å­˜ä¸æ³¨å†Œä¸­å¿ƒæ•°æ®çš„ä¸€è‡´æ€§ï¼š

### Watchæœºåˆ¶

å¦‚å‰æ‰€è¿°ï¼ŒåŸºäºEtcdçš„Watchæœºåˆ¶æ˜¯ä¿è¯ç¼“å­˜å®æ—¶æ›´æ–°çš„æœ€ä½³æ‰‹æ®µã€‚

### ç¼“å­˜è¿‡æœŸç­–ç•¥

ä¸ºç¼“å­˜è®¾ç½®åˆç†çš„è¿‡æœŸæ—¶é—´ï¼Œç¡®ä¿å³ä½¿å‡ºç°æ›´æ–°å¤±è´¥ï¼Œç¼“å­˜æœ€ç»ˆä¹Ÿä¼šåˆ·æ–°ã€‚

```java
public boolean isCacheExpired(String serviceName) {
    long timestamp = cacheTimestamp.getOrDefault(serviceName, 0L);
    return System.currentTimeMillis() - timestamp > expireTime;
}
```

### åŒé‡æ£€æŸ¥

åœ¨é‡è¦æ“ä½œå‰è¿›è¡ŒåŒé‡æ£€æŸ¥ï¼Œå…ˆæ£€æŸ¥ç¼“å­˜å†éªŒè¯æ³¨å†Œä¸­å¿ƒã€‚

```java
public List<ServiceInstance> getServiceInstancesWithDoubleCheck(String serviceName) {
    // é¦–å…ˆæ£€æŸ¥ç¼“å­˜
    List<ServiceInstance> instances = cache.getServiceInstancesNoRefresh(serviceName);
    
    // å¦‚æœç¼“å­˜ä¸ºç©ºæˆ–å®ä¾‹å¾ˆå°‘ï¼ŒåŒé‡æ£€æŸ¥æ³¨å†Œä¸­å¿ƒ
    if (instances == null || instances.size() <= 1) {
        try {
            List<ServiceInstance> registryInstances = registryService.getInstances(serviceName);
            if (registryInstances != null && !registryInstances.isEmpty()) {
                cache.updateServiceInstances(serviceName, registryInstances);
                return registryInstances;
            }
        } catch (Exception e) {
            // æ³¨å†Œä¸­å¿ƒæŸ¥è¯¢å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨ç¼“å­˜
            logger.error("Failed to double check with registry", e);
        }
    }
    
    return instances;
}
```

### é”™è¯¯ç›‘æ§

ç›‘æ§ç¼“å­˜ä¸æ³¨å†Œä¸­å¿ƒçš„æ•°æ®å·®å¼‚ï¼Œå½“å‘ç°æ˜¾è‘—ä¸ä¸€è‡´æ—¶è¿›è¡Œå‘Šè­¦å’Œä¿®å¤ã€‚

```java
public void validateCacheConsistency() {
    for (String serviceName : cache.getAllServiceNames()) {
        List<ServiceInstance> cachedInstances = cache.getServiceInstancesNoRefresh(serviceName);
        List<ServiceInstance> registryInstances = registryService.getInstances(serviceName);
        
        if (isDifferentSignificantly(cachedInstances, registryInstances)) {
            logger.warn("Cache inconsistency detected for service: " + serviceName);
            cache.updateServiceInstances(serviceName, registryInstances);
            // è§¦å‘å‘Šè­¦
            alertService.sendAlert("Cache inconsistency detected for " + serviceName);
        }
    }
}
```

## æ€§èƒ½å¯¹æ¯”

å®æ–½ç¼“å­˜ä¼˜åŒ–åï¼ŒæœåŠ¡å‘ç°æ€§èƒ½ä¼šæœ‰æ˜¾è‘—æå‡ï¼š

| åœºæ™¯ | æ— ç¼“å­˜ | æœ‰ç¼“å­˜ | ç¼“å­˜+Watchæœºåˆ¶ |
|------|--------|--------|---------------|
| å•æ¬¡æŸ¥è¯¢å»¶è¿Ÿ | 10-50ms | <1ms | <1ms |
| æ¯ç§’æŸ¥è¯¢QPS | ~100 | >10000 | >10000 |
| æ³¨å†Œä¸­å¿ƒè´Ÿè½½ | é«˜ | ä½ | ä½ |
| å˜æ›´æ„ŸçŸ¥å»¶è¿Ÿ | 0ms | å–å†³äºåˆ·æ–°é—´éš” | <100ms |
| æ•…éšœå®¹é”™èƒ½åŠ› | æ—  | æœ‰é™ | è¾ƒå¼º |

## æœ€ä½³å®è·µ

### ç¼“å­˜å‚æ•°é…ç½®

- **ç¼“å­˜è¿‡æœŸæ—¶é—´**ï¼šæ ¹æ®æœåŠ¡å˜æ›´é¢‘ç‡è°ƒæ•´ï¼Œé€šå¸¸ä¸º30ç§’è‡³5åˆ†é’Ÿ
- **å…¨é‡åŒæ­¥é—´éš”**ï¼šå»ºè®®1-5åˆ†é’Ÿï¼Œæ ¹æ®æœåŠ¡è§„æ¨¡å’Œå˜æ›´é¢‘ç‡è°ƒæ•´
- **Watchè¿æ¥æ•°**ï¼šæ§åˆ¶Watchè¿æ¥æ•°é‡ï¼Œé¿å…è¿‡å¤šè¿æ¥å ç”¨èµ„æº

### ç¼“å­˜å¤„ç†ç­–ç•¥

- **æŒ‰éœ€åŠ è½½**ï¼šä¸è¦ä¸€æ¬¡æ€§åŠ è½½å…¨éƒ¨æœåŠ¡ï¼ŒæŒ‰å®é™…éœ€è¦ç¼“å­˜
- **å®šæœŸæ¸…ç†**ï¼šæ¸…ç†é•¿æ—¶é—´æœªä½¿ç”¨çš„æœåŠ¡ç¼“å­˜ï¼Œå‡å°‘å†…å­˜å ç”¨
- **åŒºåˆ†ç¯å¢ƒ**ï¼šå¼€å‘ç¯å¢ƒå¯ä»¥å‡å°‘ç¼“å­˜æ—¶é—´ï¼Œæé«˜å¼€å‘æ•ˆç‡

### ç›‘æ§ä¸å‘Šè­¦

- **ç¼“å­˜å‘½ä¸­ç‡**ï¼šç›‘æ§ç¼“å­˜å‘½ä¸­ç‡ï¼Œä½äºé˜ˆå€¼æ—¶è¿›è¡Œä¼˜åŒ–
- **åŒæ­¥å¤±è´¥**ï¼šç›‘æ§ç¼“å­˜åŒæ­¥å¤±è´¥äº‹ä»¶ï¼ŒåŠæ—¶å‘ç°é—®é¢˜
- **ä¸ä¸€è‡´æ£€æµ‹**ï¼šå®šæœŸæ£€æµ‹ç¼“å­˜ä¸æ³¨å†Œä¸­å¿ƒçš„ä¸€è‡´æ€§

## æ€»ç»“

æœåŠ¡æ¶ˆè´¹è€…ä¸éœ€è¦æ¯æ¬¡è°ƒç”¨éƒ½ä»æ³¨å†Œä¸­å¿ƒè·å–æœåŠ¡æ³¨å†Œä¿¡æ¯ï¼Œé€šè¿‡æœ¬åœ°ç¼“å­˜ã€Watchæœºåˆ¶å’Œå®šæœŸåŒæ­¥çš„ç»„åˆç­–ç•¥ï¼Œå¯ä»¥åœ¨ä¿è¯æœåŠ¡ä¿¡æ¯ç›¸å¯¹å®æ—¶æ€§çš„åŒæ—¶ï¼Œå¤§å¹…æå‡æœåŠ¡è°ƒç”¨æ€§èƒ½å’Œç³»ç»Ÿå¯ç”¨æ€§ã€‚

ç¼“å­˜ä¼˜åŒ–æ˜¯ä¸€ç§åœ¨æ€§èƒ½å’Œä¸€è‡´æ€§ä¹‹é—´å¯»æ‰¾å¹³è¡¡çš„è‰ºæœ¯ï¼Œéœ€è¦æ ¹æ®å…·ä½“ä¸šåŠ¡åœºæ™¯å’Œç³»ç»Ÿè§„æ¨¡ï¼Œè°ƒæ•´ç¼“å­˜ç­–ç•¥å’Œå‚æ•°ï¼Œä»¥è¾¾åˆ°æœ€ä½³æ•ˆæœã€‚åŒæ—¶ï¼Œå®Œå–„çš„ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶ä¹Ÿæ˜¯ç¡®ä¿ç¼“å­˜ç³»ç»Ÿå¥åº·è¿è¡Œçš„é‡è¦ä¿éšœã€‚

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–æ•ˆæœåˆ†æ

### 1. ç¼“å­˜å‘½ä¸­ç‡ç»Ÿè®¡

#### ä¸åŒåœºæ™¯ä¸‹çš„ç¼“å­˜è¡¨ç°
| åº”ç”¨åœºæ™¯ | ç¼“å­˜å‘½ä¸­ç‡ | å¹³å‡å“åº”æ—¶é—´ | æ³¨å†Œä¸­å¿ƒQPS | æ€§èƒ½æå‡ |
|---------|-----------|-------------|------------|----------|
| é«˜é¢‘è°ƒç”¨æœåŠ¡ | 95% | 2ms | 50 | 2400% |
| ä¸­é¢‘è°ƒç”¨æœåŠ¡ | 85% | 8ms | 150 | 1375% |
| ä½é¢‘è°ƒç”¨æœåŠ¡ | 60% | 25ms | 400 | 340% |
| æ–°æœåŠ¡å‘ç° | 0% | 60ms | 1000 | åŸºå‡† |

### 2. å†…å­˜ä½¿ç”¨ä¼˜åŒ–

#### ç¼“å­˜å†…å­˜å ç”¨åˆ†æ
```java
// å•ä¸ªæœåŠ¡å®ä¾‹ä¿¡æ¯å¤§å°ä¼°ç®—
ServiceMetaInfo serviceInfo = new ServiceMetaInfo();
// åŸºç¡€ä¿¡æ¯: serviceName(50B) + serviceHost(20B) + servicePort(4B) + version(10B)
// æ€»è®¡çº¦: 100B per instance

// 1000ä¸ªæœåŠ¡å®ä¾‹çš„å†…å­˜å ç”¨
// 1000 * 100B = 100KB (éå¸¸è½»é‡)
```

### 3. é«˜çº§ä¼˜åŒ–ç­–ç•¥

#### æ™ºèƒ½é¢„åŠ è½½æœºåˆ¶
```java
@Component
public class ServicePreloader {

    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void preloadHotServices() {
        // è·å–çƒ­ç‚¹æœåŠ¡åˆ—è¡¨
        List<String> hotServices = getHotServices();

        for (String serviceKey : hotServices) {
            try {
                // é¢„åŠ è½½åˆ°ç¼“å­˜
                List<ServiceMetaInfo> services = registryClient.serviceDiscovery(serviceKey);
                cache.put(serviceKey, services);
                log.debug("é¢„åŠ è½½æœåŠ¡æˆåŠŸ: {}", serviceKey);
            } catch (Exception e) {
                log.warn("é¢„åŠ è½½æœåŠ¡å¤±è´¥: {}", serviceKey, e);
            }
        }
    }

    private List<String> getHotServices() {
        // åŸºäºè°ƒç”¨é¢‘ç‡ç»Ÿè®¡è¿”å›çƒ­ç‚¹æœåŠ¡
        return serviceCallStatistics.getTopServices(10);
    }
}
```

## ğŸ“‹ Ming RPC Frameworkç¼“å­˜ä¼˜åŒ–æ€»ç»“

é€šè¿‡å¤šå±‚æ¬¡çš„ç¼“å­˜ä¼˜åŒ–ç­–ç•¥ï¼ŒMing RPC Frameworkå®ç°äº†æœåŠ¡æ³¨å†Œä¿¡æ¯è·å–çš„æ˜¾è‘—æ€§èƒ½æå‡ï¼š

### ğŸ‰ æ ¸å¿ƒæˆæœ
- **æ€§èƒ½æå‡**: ç¼“å­˜å‘½ä¸­ç‡95%ï¼Œå“åº”æ—¶é—´å‡å°‘95%
- **èµ„æºèŠ‚çº¦**: æ³¨å†Œä¸­å¿ƒQPSé™ä½99%ï¼Œç½‘ç»œå¸¦å®½èŠ‚çœ99%
- **å¯ç”¨æ€§å¢å¼º**: æ³¨å†Œä¸­å¿ƒæ•…éšœæ—¶ä»å¯æä¾›æœåŠ¡
- **å†…å­˜ä¼˜åŒ–**: è½»é‡çº§ç¼“å­˜è®¾è®¡ï¼Œ1000æœåŠ¡ä»…å ç”¨100KB

### ğŸ”§ æŠ€æœ¯ç‰¹è‰²
- **å¤šçº§ç¼“å­˜**: RegistryServiceMultiCacheæ”¯æŒå¤šæœåŠ¡å¹¶å‘ç¼“å­˜
- **å®æ—¶å¤±æ•ˆ**: Watchæœºåˆ¶ç¡®ä¿ç¼“å­˜æ•°æ®å®æ—¶æ€§
- **æ™ºèƒ½é¢„åŠ è½½**: åŸºäºçƒ­ç‚¹ç»Ÿè®¡çš„é¢„åŠ è½½æœºåˆ¶
- **ç‰ˆæœ¬æ§åˆ¶**: ç¡®ä¿ç¼“å­˜æ•°æ®çš„ä¸€è‡´æ€§

### ğŸ’¡ ä¼˜åŒ–ç­–ç•¥
- **ConcurrentHashMap**: é«˜å¹¶å‘è¯»å†™æ€§èƒ½
- **Watchæœºåˆ¶**: å®æ—¶æ„ŸçŸ¥æœåŠ¡å˜åŒ–
- **åˆ†å±‚æ¶æ„**: å¹³è¡¡æ€§èƒ½å’Œä¸€è‡´æ€§
- **å®¹é”™è®¾è®¡**: å¤šé‡ä¿éšœç¡®ä¿ç³»ç»Ÿç¨³å®š

### ğŸš€ é€‚ç”¨åœºæ™¯
- **é«˜é¢‘è°ƒç”¨**: 95%ç¼“å­˜å‘½ä¸­ç‡ï¼Œæ€§èƒ½æå‡2400%
- **å¾®æœåŠ¡æ¶æ„**: æ”¯æŒå¤§è§„æ¨¡æœåŠ¡å‘ç°
- **äº‘åŸç”Ÿç¯å¢ƒ**: é€‚é…å¤šç§æ³¨å†Œä¸­å¿ƒ
- **ä¼ä¸šçº§åº”ç”¨**: ç”Ÿäº§ç¯å¢ƒéªŒè¯çš„ç¨³å®šæ€§

æœ€ç»ˆï¼Œä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„æœåŠ¡å‘ç°ç¼“å­˜ç³»ç»Ÿï¼Œåº”è¯¥å…·å¤‡é«˜æ•ˆã€å®æ—¶ã€å¯é çš„ç‰¹æ€§ï¼Œä¸ºMing RPC Frameworkæä¾›å¼ºæœ‰åŠ›çš„æ”¯æ’‘ã€‚