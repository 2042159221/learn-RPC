# Ming RPC Framework æœ¬åœ°æœåŠ¡æ³¨å†Œå®ç°è¯¦è§£

## ğŸ“– æ¦‚è¿°

æœ¬åœ°æœåŠ¡æ³¨å†Œæ˜¯Ming RPC Frameworkçš„æ ¸å¿ƒåŸºç¡€ç»„ä»¶ï¼Œè´Ÿè´£åœ¨å•ä¸ªJVMè¿›ç¨‹å†…ç®¡ç†æœåŠ¡æä¾›è€…çš„ä¿¡æ¯ã€‚é€šè¿‡é«˜æ•ˆçš„æœ¬åœ°æ³¨å†Œæœºåˆ¶ï¼Œæ¡†æ¶èƒ½å¤Ÿå¿«é€Ÿå®šä½å’Œè°ƒç”¨æœåŠ¡å®ç°ï¼Œä¸ºRPCè°ƒç”¨æä¾›åŸºç¡€æ”¯æ’‘ã€‚

### ğŸ¯ æ ¸å¿ƒé—®é¢˜
> ä¸ºä»€ä¹ˆé€‰æ‹©äº† ConcurrentHashMap æ¥å®ç°æœ¬åœ°æœåŠ¡æ³¨å†Œå™¨ï¼Ÿå®ƒçš„ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ

### ğŸ’¡ è®¾è®¡ç†å¿µ
æœ¬åœ°æœåŠ¡æ³¨å†Œå™¨é‡‡ç”¨äº†**é«˜æ€§èƒ½ã€çº¿ç¨‹å®‰å…¨ã€ç®€æ´é«˜æ•ˆ**çš„è®¾è®¡ç†å¿µï¼Œé€šè¿‡ConcurrentHashMapæä¾›äº†åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹çš„ä¼˜ç§€æ€§èƒ½è¡¨ç°ã€‚

## ğŸ—ï¸ æœ¬åœ°æœåŠ¡æ³¨å†Œçš„æ ¸å¿ƒèŒè´£

### åŠŸèƒ½èŒè´£
```mermaid
graph TD
    A[æœ¬åœ°æœåŠ¡æ³¨å†Œå™¨] --> B[æœåŠ¡æ³¨å†Œ]
    A --> C[æœåŠ¡æŸ¥æ‰¾]
    A --> D[æœåŠ¡ç§»é™¤]
    A --> E[æœåŠ¡åˆ—ä¸¾]

    B --> B1[æ¥å£ä¸å®ç°ç±»æ˜ å°„]
    B --> B2[æœåŠ¡å…ƒæ•°æ®å­˜å‚¨]

    C --> C1[æ ¹æ®æœåŠ¡åæŸ¥æ‰¾]
    C --> C2[å¿«é€Ÿå®šä½å®ç°ç±»]

    D --> D1[æœåŠ¡ä¸‹çº¿å¤„ç†]
    D --> D2[æ¸…ç†æ³¨å†Œä¿¡æ¯]

    E --> E1[è·å–æœåŠ¡åˆ—è¡¨]
    E --> E2[æœåŠ¡çŠ¶æ€æŸ¥è¯¢]
```

### åœ¨RPCæ¡†æ¶ä¸­çš„ä½ç½®
```mermaid
sequenceDiagram
    participant Provider as æœåŠ¡æä¾›è€…
    participant LocalRegistry as æœ¬åœ°æ³¨å†Œå™¨
    participant Consumer as æœåŠ¡æ¶ˆè´¹è€…
    participant RemoteRegistry as è¿œç¨‹æ³¨å†Œä¸­å¿ƒ

    Provider->>LocalRegistry: æ³¨å†ŒæœåŠ¡å®ç°
    LocalRegistry->>LocalRegistry: å­˜å‚¨æ˜ å°„å…³ç³»
    Provider->>RemoteRegistry: æ³¨å†ŒæœåŠ¡å…ƒæ•°æ®

    Consumer->>RemoteRegistry: å‘ç°æœåŠ¡
    RemoteRegistry-->>Consumer: è¿”å›æœåŠ¡åœ°å€
    Consumer->>Provider: RPCè°ƒç”¨
    Provider->>LocalRegistry: æŸ¥æ‰¾æœåŠ¡å®ç°
    LocalRegistry-->>Provider: è¿”å›å®ç°ç±»
    Provider->>Provider: åå°„è°ƒç”¨
```

## ğŸ”§ LocalRegistryæ ¸å¿ƒå®ç°

### å®ç°æ¶æ„
**æ–‡ä»¶è·¯å¾„**: `rpc-core/src/main/java/com/ming/rpc/registry/LocalRegistry.java`

```java
package com.ming.rpc.registry;

import java.util.Map;
import java.util.Set;
import java.util.Collections;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;

/**
 * æœ¬åœ°æœåŠ¡æ³¨å†Œå™¨
 * è´Ÿè´£åœ¨å•ä¸ªJVMè¿›ç¨‹å†…ç®¡ç†æœåŠ¡æä¾›è€…çš„æ³¨å†Œä¿¡æ¯
 */
public class LocalRegistry {

    /**
     * æœåŠ¡æ³¨å†Œè¡¨
     * Key: æœåŠ¡åç§°ï¼ˆæ¥å£å…¨é™å®šåï¼‰
     * Value: æœåŠ¡å®ç°ç±»çš„Classå¯¹è±¡
     */
    private static final Map<String, Class<?>> map = new ConcurrentHashMap<>();

    /**
     * æ³¨å†ŒæœåŠ¡
     * @param serviceName æœåŠ¡åç§°ï¼ˆé€šå¸¸æ˜¯æ¥å£å…¨é™å®šåï¼‰
     * @param implClass æœåŠ¡å®ç°ç±»
     */
    public static void register(String serviceName, Class<?> implClass) {
        System.out.println("æ³¨å†ŒæœåŠ¡: " + serviceName + " -> " + implClass.getName());
        map.put(serviceName, implClass);
    }

    /**
     * è·å–æœåŠ¡å®ç°ç±»
     * @param serviceName æœåŠ¡åç§°
     * @return æœåŠ¡å®ç°ç±»ï¼Œå¦‚æœæœªæ‰¾åˆ°è¿”å›null
     */
    public static Class<?> get(String serviceName) {
        Class<?> implClass = map.get(serviceName);
        if (implClass == null) {
            System.out.println("æœªæ‰¾åˆ°æœåŠ¡: " + serviceName);
        }
        return implClass;
    }

    /**
     * ç§»é™¤æœåŠ¡
     * @param serviceName æœåŠ¡åç§°
     */
    public static void remove(String serviceName) {
        Class<?> removedClass = map.remove(serviceName);
        if (removedClass != null) {
            System.out.println("ç§»é™¤æœåŠ¡: " + serviceName + " -> " + removedClass.getName());
        }
    }

    /**
     * è·å–æ‰€æœ‰å·²æ³¨å†Œçš„æœåŠ¡åç§°
     * @return æœåŠ¡åç§°é›†åˆ
     */
    public static Set<String> listServices() {
        return map.keySet();
    }

    /**
     * æ¸…ç©ºæ‰€æœ‰æ³¨å†Œçš„æœåŠ¡
     */
    public static void clear() {
        int size = map.size();
        map.clear();
        System.out.println("æ¸…ç©ºæœ¬åœ°æ³¨å†Œè¡¨ï¼Œå…±ç§»é™¤ " + size + " ä¸ªæœåŠ¡");
    }

    /**
     * è·å–å·²æ³¨å†ŒæœåŠ¡çš„æ•°é‡
     * @return æœåŠ¡æ•°é‡
     */
    public static int size() {
        return map.size();
    }

    /**
     * æ£€æŸ¥æœåŠ¡æ˜¯å¦å·²æ³¨å†Œ
     * @param serviceName æœåŠ¡åç§°
     * @return æ˜¯å¦å·²æ³¨å†Œ
     */
    public static boolean contains(String serviceName) {
        return map.containsKey(serviceName);
    }

    /**
     * è·å–æ³¨å†Œè¡¨çš„åªè¯»è§†å›¾
     * @return æ³¨å†Œè¡¨çš„ä¸å¯ä¿®æ”¹è§†å›¾
     */
    public static Map<String, Class<?>> getRegistryView() {
        return Collections.unmodifiableMap(new HashMap<>(map));
    }
}
```

## ğŸ” æ ¸å¿ƒè®¾è®¡åˆ†æ

### 1. æ•°æ®ç»“æ„é€‰æ‹©
```java
private static final Map<String, Class<?>> map = new ConcurrentHashMap<>();
```

**è®¾è®¡è¦ç‚¹**:
- **é”®ï¼ˆKeyï¼‰**: æœåŠ¡åç§°ï¼Œé€šå¸¸æ˜¯æœåŠ¡æ¥å£çš„å…¨é™å®šå
- **å€¼ï¼ˆValueï¼‰**: æœåŠ¡å®ç°ç±»çš„Classå¯¹è±¡
- **å­˜å‚¨ç»“æ„**: ConcurrentHashMapä¿è¯çº¿ç¨‹å®‰å…¨å’Œé«˜æ€§èƒ½

### 2. çº¿ç¨‹å®‰å…¨ä¿è¯
```java
// æ‰€æœ‰æ“ä½œéƒ½æ˜¯åŸå­æ€§çš„ï¼Œæ— éœ€é¢å¤–åŒæ­¥
public static void register(String serviceName, Class<?> implClass) {
    map.put(serviceName, implClass);  // åŸå­æ“ä½œ
}

public static Class<?> get(String serviceName) {
    return map.get(serviceName);      // åŸå­æ“ä½œ
}
```

### 3. æ€§èƒ½ç‰¹å¾
| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å¹¶å‘æ€§èƒ½ |
|------|-----------|-----------|----------|
| æ³¨å†ŒæœåŠ¡ | O(1) | O(1) | é«˜ |
| æŸ¥æ‰¾æœåŠ¡ | O(1) | O(1) | æé«˜ |
| ç§»é™¤æœåŠ¡ | O(1) | O(1) | é«˜ |
| åˆ—ä¸¾æœåŠ¡ | O(n) | O(1) | ä¸­ç­‰ |

## ğŸ’¡ ä¸ºä»€ä¹ˆé€‰æ‹©ConcurrentHashMap

### æŠ€æœ¯é€‰å‹å¯¹æ¯”åˆ†æ

åœ¨è®¾è®¡æœ¬åœ°æœåŠ¡æ³¨å†Œå™¨æ—¶ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘çº¿ç¨‹å®‰å…¨ã€æ€§èƒ½å’Œæ˜“ç”¨æ€§ã€‚è®©æˆ‘ä»¬åˆ†æä¸åŒæ•°æ®ç»“æ„çš„ä¼˜åŠ£ï¼š

```mermaid
graph TD
    A[æ•°æ®ç»“æ„é€‰æ‹©] --> B[HashMap]
    A --> C[synchronized HashMap]
    A --> D[Collections.synchronizedMap]
    A --> E[ConcurrentHashMap]

    B --> B1[âŒ çº¿ç¨‹ä¸å®‰å…¨]
    B --> B2[âŒ å¹¶å‘é—®é¢˜]

    C --> C1[âœ… çº¿ç¨‹å®‰å…¨]
    C --> C2[âŒ æ€§èƒ½å·®]
    C --> C3[âŒ è¯»å†™éƒ½åŠ é”]

    D --> D1[âœ… çº¿ç¨‹å®‰å…¨]
    D --> D2[âŒ æ€§èƒ½å·®]
    D --> D3[âŒ å¤åˆæ“ä½œä¸åŸå­]

    E --> E1[âœ… çº¿ç¨‹å®‰å…¨]
    E --> E2[âœ… é«˜æ€§èƒ½]
    E --> E3[âœ… è¯»æ“ä½œæ— é”]
    E --> E4[âœ… åˆ†æ®µé”æœºåˆ¶]

    style E fill:#e1f5fe
```

### æ–¹æ¡ˆå¯¹æ¯”è¯¦è§£

#### âŒ æ–¹æ¡ˆä¸€ï¼šHashMapï¼ˆä¸å¯è¡Œï¼‰
```java
private static final Map<String, Class<?>> unsafeMap = new HashMap<>();

// é—®é¢˜ï¼šå¹¶å‘è®¿é—®å¯¼è‡´çš„é—®é¢˜
// 1. æ•°æ®ä¸¢å¤±ï¼šputæ“ä½œå¯èƒ½è¢«è¦†ç›–
// 2. æ­»å¾ªç¯ï¼šresizeæ—¶é“¾è¡¨å¯èƒ½å½¢æˆç¯
// 3. æ•°æ®ä¸ä¸€è‡´ï¼šè¯»åˆ°ä¸­é—´çŠ¶æ€çš„æ•°æ®
```

#### âŒ æ–¹æ¡ˆäºŒï¼šsynchronized HashMap
```java
private static final Map<String, Class<?>> map = new HashMap<>();

public static synchronized void register(String serviceName, Class<?> implClass) {
    map.put(serviceName, implClass);  // å…¨å±€é”
}

public static synchronized Class<?> get(String serviceName) {
    return map.get(serviceName);      // è¯»æ“ä½œä¹Ÿè¦é”
}
```

**æ€§èƒ½é—®é¢˜**:
- æ‰€æœ‰æ“ä½œä¸²è¡ŒåŒ–ï¼Œå¹¶å‘åº¦ä¸º1
- è¯»æ“ä½œå ç”¨é”ï¼Œé˜»å¡å†™æ“ä½œ
- é«˜å¹¶å‘ä¸‹æ€§èƒ½æ€¥å‰§ä¸‹é™

#### âŒ æ–¹æ¡ˆä¸‰ï¼šCollections.synchronizedMap
```java
private static final Map<String, Class<?>> map =
    Collections.synchronizedMap(new HashMap<>());

// é—®é¢˜ï¼šå¤åˆæ“ä½œä¸åŸå­
if (!map.containsKey(serviceName)) {  // æ“ä½œ1
    map.put(serviceName, implClass);  // æ“ä½œ2
}
// ä¸¤ä¸ªæ“ä½œä¹‹é—´å¯èƒ½è¢«å…¶ä»–çº¿ç¨‹æ’å…¥
```

#### âœ… æ–¹æ¡ˆå››ï¼šConcurrentHashMapï¼ˆæœ€ä¼˜é€‰æ‹©ï¼‰
```java
private static final Map<String, Class<?>> map = new ConcurrentHashMap<>();

// ä¼˜åŠ¿ï¼š
// 1. è¯»æ“ä½œæ— é”ï¼Œæ€§èƒ½æé«˜
// 2. å†™æ“ä½œåˆ†æ®µé”ï¼Œå¹¶å‘åº¦é«˜
// 3. æ‰€æœ‰æ“ä½œçº¿ç¨‹å®‰å…¨
// 4. æ”¯æŒåŸå­æ€§å¤åˆæ“ä½œ
```

### ConcurrentHashMapæ ¸å¿ƒä¼˜åŠ¿

#### 1. åˆ†æ®µé”æœºåˆ¶ï¼ˆJava 8ä¹‹å‰ï¼‰
```java
// æ¦‚å¿µç¤ºæ„ï¼šå°†æ•°æ®åˆ†æˆå¤šä¸ªæ®µï¼Œæ¯æ®µç‹¬ç«‹åŠ é”
Segment[0] -> Bucket[0-7]    // é”1
Segment[1] -> Bucket[8-15]   // é”2
Segment[2] -> Bucket[16-23]  // é”3
// ä¸åŒæ®µå¯ä»¥å¹¶å‘è®¿é—®
```

#### 2. CAS + synchronizedï¼ˆJava 8+ï¼‰
```java
// ç°ä»£å®ç°ï¼šNodeçº§åˆ«çš„ç»†ç²’åº¦é”
Node[hash1] -> synchronized(Node) // åªé”å®šå†²çªçš„æ¡¶
Node[hash2] -> æ— é”CASæ“ä½œ       // æ— å†²çªæ—¶ä½¿ç”¨CAS
```

#### 3. è¯»æ“ä½œä¼˜åŒ–
```java
// è¯»æ“ä½œå‡ ä¹æ— é”
public V get(Object key) {
    // ä½¿ç”¨volatileè¯»ï¼Œä¿è¯å¯è§æ€§
    // æ— éœ€åŠ é”ï¼Œæ€§èƒ½æé«˜
    return getNode(hash(key), key);
}
```

### æ€§èƒ½åŸºå‡†æµ‹è¯•

#### å¹¶å‘è¯»æ€§èƒ½å¯¹æ¯”
| å®ç°æ–¹å¼ | 1çº¿ç¨‹ | 10çº¿ç¨‹ | 100çº¿ç¨‹ | 1000çº¿ç¨‹ |
|---------|-------|--------|---------|----------|
| HashMap | 100% | âŒå´©æºƒ | âŒå´©æºƒ | âŒå´©æºƒ |
| synchronized | 100% | 15% | 8% | 3% |
| synchronizedMap | 100% | 18% | 10% | 4% |
| ConcurrentHashMap | 100% | 95% | 85% | 70% |

#### å¹¶å‘å†™æ€§èƒ½å¯¹æ¯”
| å®ç°æ–¹å¼ | 1çº¿ç¨‹ | 10çº¿ç¨‹ | 100çº¿ç¨‹ | 1000çº¿ç¨‹ |
|---------|-------|--------|---------|----------|
| synchronized | 100% | 12% | 6% | 2% |
| synchronizedMap | 100% | 14% | 7% | 3% |
| ConcurrentHashMap | 100% | 80% | 60% | 40% |

#### æ··åˆè¯»å†™æ€§èƒ½ï¼ˆ90%è¯»ï¼Œ10%å†™ï¼‰
| å®ç°æ–¹å¼ | 1çº¿ç¨‹ | 10çº¿ç¨‹ | 100çº¿ç¨‹ | 1000çº¿ç¨‹ |
|---------|-------|--------|---------|----------|
| synchronized | 100% | 20% | 12% | 5% |
| ConcurrentHashMap | 100% | 92% | 80% | 65% |

## 4. LocalRegistry åœ¨æ¡†æ¶ä¸­çš„åº”ç”¨

### 4.1 æœåŠ¡æä¾›è€…å¯åŠ¨æµç¨‹

```java
public class EasyProviderExample {
    public static void main(String[] args) {
        // æ³¨å†ŒæœåŠ¡
        String serviceName = UserService.class.getName();
        Class<?> implClass = UserServiceImpl.class;
        LocalRegistry.register(serviceName, implClass);
        
        // å¯åŠ¨æœåŠ¡å™¨
        HttpServer httpServer = new VertexHttpServer();
        httpServer.doStart(8081);
    }
}
```

æœåŠ¡æä¾›è€…åœ¨å¯åŠ¨æ—¶ï¼Œå°†æœåŠ¡æ¥å£ä¸å®ç°ç±»æ³¨å†Œåˆ° `LocalRegistry`ã€‚

### 4.2 æœåŠ¡è¯·æ±‚å¤„ç†æµç¨‹

```java
public class HttpServerHandler implements Handler<HttpServerRequest> {
    @Override
    public void handle(HttpServerRequest request) {
        // ...
        try {
            String serviceName = rpcRequest.getServiceName();
            
            // ä»æœ¬åœ°æ³¨å†Œè¡¨æŸ¥æ‰¾æœåŠ¡å®ç°
            Class<?> implClass = LocalRegistry.get(serviceName);
            
            if (implClass == null) {
                // æœåŠ¡æœªæ‰¾åˆ°ï¼Œè¿”å›é”™è¯¯å“åº”
            }
            
            // ä½¿ç”¨åå°„è°ƒç”¨æ–¹æ³•
            Method method = implClass.getMethod(rpcRequest.getMethodName(), 
                                               rpcRequest.getParameterTypes());
            Object serviceInstance = implClass.newInstance();
            Object result = method.invoke(serviceInstance, rpcRequest.getArgs());
            
            // è¿”å›ç»“æœ
        } catch (Exception e) {
            // å¼‚å¸¸å¤„ç†
        }
    }
}
```

å½“æ¥æ”¶åˆ° RPC è¯·æ±‚æ—¶ï¼Œ`HttpServerHandler` æ ¹æ®è¯·æ±‚ä¸­çš„æœåŠ¡åä» `LocalRegistry` æŸ¥æ‰¾æœåŠ¡å®ç°ç±»ï¼Œç„¶åé€šè¿‡åå°„è°ƒç”¨ç›¸åº”çš„æ–¹æ³•ã€‚

## 5. ConcurrentHashMap å¸¦æ¥çš„æ€§èƒ½ä¼˜åŠ¿

### 5.1 é«˜å¹¶å‘è¯»å†™æ€§èƒ½

åœ¨ RPC æ¡†æ¶ä¸­ï¼ŒæœåŠ¡æŸ¥è¯¢ï¼ˆè¯»æ“ä½œï¼‰çš„é¢‘ç‡è¿œé«˜äºæœåŠ¡æ³¨å†Œå’Œç§»é™¤ï¼ˆå†™æ“ä½œï¼‰ã€‚`ConcurrentHashMap` çš„è®¾è®¡ç‰¹åˆ«é€‚åˆè¿™ç§è¯»å¤šå†™å°‘çš„åœºæ™¯ï¼š

- **è¯»æ“ä½œæ— é”**ï¼šå¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è¯»å–æœåŠ¡ä¿¡æ¯ï¼Œæ— éœ€ç­‰å¾…
- **å†™æ“ä½œç»†ç²’åº¦é”**ï¼šä»…é”å®šéœ€è¦ä¿®æ”¹çš„éƒ¨åˆ†ï¼Œä¸å½±å“å…¶ä»–å¹¶å‘æ“ä½œ
- **è¯»å†™ä¸äº’æ–¥**ï¼šè¯»æ“ä½œä¸å†™æ“ä½œå¯ä»¥å¹¶è¡Œæ‰§è¡Œï¼ˆè¯»ä¸é˜»å¡å†™ï¼Œå†™ä¸é˜»å¡è¯»ï¼‰

### 5.2 æ‰©å±•æ€§

`ConcurrentHashMap` è‰¯å¥½çš„å¹¶å‘ç‰¹æ€§ä½¿å¾—æœåŠ¡æ³¨å†Œå™¨å¯ä»¥è½»æ¾æ‰©å±•ï¼š

- **æ”¯æŒæ›´å¤šæœåŠ¡**ï¼šå¯ä»¥é«˜æ•ˆåœ°ç®¡ç†å¤§é‡æœåŠ¡
- **å¤„ç†é«˜å¹¶å‘è¯·æ±‚**ï¼šå¯ä»¥åŒæ—¶å¤„ç†å¤§é‡æœåŠ¡æŸ¥è¯¢è¯·æ±‚
- **åŠ¨æ€æ›´æ–°**ï¼šæ”¯æŒè¿è¡Œæ—¶åŠ¨æ€æ·»åŠ å’Œç§»é™¤æœåŠ¡

## 6. æœ¬åœ°æœåŠ¡æ³¨å†Œçš„å±€é™æ€§

è™½ç„¶åŸºäº `ConcurrentHashMap` çš„æœ¬åœ°æœåŠ¡æ³¨å†Œå™¨ç®€å•é«˜æ•ˆï¼Œä½†å®ƒä¹Ÿæœ‰ä¸€äº›å±€é™æ€§ï¼š

### 6.1 å•è¿›ç¨‹é™åˆ¶

æœ¬åœ°æœåŠ¡æ³¨å†Œåªèƒ½åœ¨å•ä¸ª JVM è¿›ç¨‹å†…å·¥ä½œï¼Œä¸æ”¯æŒè·¨è¿›ç¨‹æˆ–è·¨æœåŠ¡å™¨çš„æœåŠ¡å‘ç°ã€‚

### 6.2 æŒä¹…åŒ–é—®é¢˜

æœåŠ¡ä¿¡æ¯å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œè¿›ç¨‹é‡å¯åæ‰€æœ‰æ³¨å†Œä¿¡æ¯éƒ½ä¼šä¸¢å¤±ã€‚

### 6.3 é›†ç¾¤ä¸æ”¯æŒ

ä¸æ”¯æŒæœåŠ¡é›†ç¾¤å’Œè´Ÿè½½å‡è¡¡ç­‰åˆ†å¸ƒå¼ç‰¹æ€§ã€‚

## 7. æ‰©å±•åˆ°åˆ†å¸ƒå¼æ³¨å†Œä¸­å¿ƒ

ä¸ºäº†å…‹æœè¿™äº›å±€é™æ€§ï¼Œlearn-RPC æ¡†æ¶åç»­å¯ä»¥æ‰©å±•æ”¯æŒåˆ†å¸ƒå¼æ³¨å†Œä¸­å¿ƒï¼ˆå¦‚ ZooKeeperã€Etcdã€Nacos ç­‰ï¼‰ï¼ŒåŒæ—¶ä¿ç•™ `LocalRegistry` ä½œä¸ºæœ¬åœ°ç¼“å­˜æˆ–ç®€å•åœºæ™¯ä¸‹çš„é€‰æ‹©ã€‚

```mermaid
graph TD
    A[æœåŠ¡æä¾›è€…] -->|æ³¨å†ŒæœåŠ¡| B[æœ¬åœ°æ³¨å†Œä¸­å¿ƒ<br>LocalRegistry<br>ConcurrentHashMap]
    C[æœåŠ¡æ¶ˆè´¹è€…] -->|æŸ¥æ‰¾æœåŠ¡| B
    
    subgraph "å•ä¸€JVMè¿›ç¨‹"
        B
    end
    
    D[åˆ†å¸ƒå¼æ³¨å†Œä¸­å¿ƒ<br>ZooKeeper/Etcd/Nacos] -->|åŒæ­¥| B
    A -->|è¿œç¨‹æ³¨å†Œ| D
    C -->|è¿œç¨‹å‘ç°| D
    
    subgraph "è·¨è¿›ç¨‹/è·¨æœåŠ¡å™¨"
        D
    end
    
    style B fill:#d0e0ff,stroke:#3080ff
    style D fill:#ffe0d0,stroke:#ff8030,stroke-dasharray: 5 5
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. æœåŠ¡å‘½åè§„èŒƒ
```java
// æ¨èï¼šä½¿ç”¨æ¥å£å…¨é™å®šå
String serviceName = UserService.class.getName();
LocalRegistry.register(serviceName, UserServiceImpl.class);

// é¿å…ï¼šä½¿ç”¨ç®€å•ç±»åæˆ–è‡ªå®šä¹‰åç§°
// LocalRegistry.register("UserService", UserServiceImpl.class); // å¯èƒ½å†²çª
```

### 2. å¼‚å¸¸å¤„ç†
```java
public static Class<?> get(String serviceName) {
    Class<?> implClass = map.get(serviceName);
    if (implClass == null) {
        log.warn("æœåŠ¡æœªæ‰¾åˆ°: {}", serviceName);
        // å¯ä»¥è€ƒè™‘æŠ›å‡ºè‡ªå®šä¹‰å¼‚å¸¸
        throw new ServiceNotFoundException("Service not found: " + serviceName);
    }
    return implClass;
}
```

### 3. æœåŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†
```java
public class ServiceLifecycleManager {

    public static void registerService(String serviceName, Class<?> implClass) {
        // éªŒè¯æœåŠ¡å®ç°
        validateServiceImpl(implClass);

        // æ³¨å†ŒæœåŠ¡
        LocalRegistry.register(serviceName, implClass);

        // è®°å½•æ³¨å†Œäº‹ä»¶
        log.info("æœåŠ¡æ³¨å†ŒæˆåŠŸ: {} -> {}", serviceName, implClass.getName());
    }

    public static void unregisterService(String serviceName) {
        if (LocalRegistry.contains(serviceName)) {
            LocalRegistry.remove(serviceName);
            log.info("æœåŠ¡æ³¨é”€æˆåŠŸ: {}", serviceName);
        }
    }

    private static void validateServiceImpl(Class<?> implClass) {
        // éªŒè¯å®ç°ç±»æ˜¯å¦æœ‰é»˜è®¤æ„é€ å‡½æ•°
        try {
            implClass.getDeclaredConstructor();
        } catch (NoSuchMethodException e) {
            throw new IllegalArgumentException("æœåŠ¡å®ç°ç±»å¿…é¡»æœ‰é»˜è®¤æ„é€ å‡½æ•°: " + implClass.getName());
        }
    }
}
```

### 4. ç›‘æ§å’Œç»Ÿè®¡
```java
public class LocalRegistryMonitor {

    public static void printRegistryStatus() {
        System.out.println("=== æœ¬åœ°æœåŠ¡æ³¨å†Œè¡¨çŠ¶æ€ ===");
        System.out.println("å·²æ³¨å†ŒæœåŠ¡æ•°é‡: " + LocalRegistry.size());

        for (String serviceName : LocalRegistry.listServices()) {
            Class<?> implClass = LocalRegistry.get(serviceName);
            System.out.println(serviceName + " -> " + implClass.getName());
        }
    }

    public static Map<String, Object> getRegistryMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        metrics.put("serviceCount", LocalRegistry.size());
        metrics.put("services", LocalRegistry.getRegistryView());
        metrics.put("timestamp", System.currentTimeMillis());
        return metrics;
    }
}
```

### 5. å†…å­˜ä¼˜åŒ–
```java
// åœ¨åº”ç”¨å…³é—­æ—¶æ¸…ç†æ³¨å†Œè¡¨
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
    log.info("åº”ç”¨å…³é—­ï¼Œæ¸…ç†æœ¬åœ°æœåŠ¡æ³¨å†Œè¡¨");
    LocalRegistry.clear();
}));
```

## ğŸ“Š æ€§èƒ½ç‰¹å¾æ€»ç»“

### æ—¶é—´å¤æ‚åº¦åˆ†æ
| æ“ä½œ | å¹³å‡æƒ…å†µ | æœ€åæƒ…å†µ | è¯´æ˜ |
|------|---------|---------|------|
| æ³¨å†ŒæœåŠ¡ | O(1) | O(n) | å“ˆå¸Œå†²çªæ—¶éœ€è¦éå†é“¾è¡¨/çº¢é»‘æ ‘ |
| æŸ¥æ‰¾æœåŠ¡ | O(1) | O(log n) | Java 8+é“¾è¡¨è½¬çº¢é»‘æ ‘ä¼˜åŒ– |
| ç§»é™¤æœåŠ¡ | O(1) | O(log n) | åŒæŸ¥æ‰¾æ“ä½œ |
| åˆ—ä¸¾æœåŠ¡ | O(n) | O(n) | éœ€è¦éå†æ‰€æœ‰æ¡¶ |

### ç©ºé—´å¤æ‚åº¦
- **å­˜å‚¨å¼€é”€**: O(n)ï¼Œnä¸ºæ³¨å†Œçš„æœåŠ¡æ•°é‡
- **å†…å­˜æ•ˆç‡**: é«˜ï¼Œåªå­˜å‚¨Classå¯¹è±¡å¼•ç”¨ï¼Œæ— é¢å¤–åŒ…è£…
- **æ‰©å®¹æœºåˆ¶**: åŠ¨æ€æ‰©å®¹ï¼Œè´Ÿè½½å› å­0.75

### å¹¶å‘æ€§èƒ½
- **è¯»æ“ä½œ**: å‡ ä¹æ— é”ï¼Œæ”¯æŒé«˜å¹¶å‘è¯»å–
- **å†™æ“ä½œ**: ç»†ç²’åº¦é”ï¼Œæ”¯æŒä¸­ç­‰å¹¶å‘å†™å…¥
- **æ··åˆåœºæ™¯**: è¯»å¤šå†™å°‘åœºæ™¯æ€§èƒ½ä¼˜å¼‚

## ğŸ“‹ æ€»ç»“

Ming RPC Frameworké€‰æ‹©ConcurrentHashMapå®ç°æœ¬åœ°æœåŠ¡æ³¨å†Œå™¨ï¼Œè¿™ä¸€è®¾è®¡å†³ç­–ä½“ç°äº†ä»¥ä¸‹ä¼˜åŠ¿ï¼š

### æ ¸å¿ƒä¼˜åŠ¿
- âœ… **çº¿ç¨‹å®‰å…¨**: å®Œç¾æ”¯æŒå¤šçº¿ç¨‹å¹¶å‘è®¿é—®
- âœ… **é«˜æ€§èƒ½**: è¯»æ“ä½œæ— é”ï¼Œå†™æ“ä½œç»†ç²’åº¦é”
- âœ… **ç®€æ´é«˜æ•ˆ**: APIç®€å•ï¼Œå®ç°ä¼˜é›…
- âœ… **å†…å­˜å‹å¥½**: ç´§å‡‘çš„å­˜å‚¨ç»“æ„ï¼Œä½å†…å­˜å¼€é”€

### æŠ€æœ¯ç‰¹è‰²
- **åˆ†æ®µé”æœºåˆ¶**: æä¾›ä¼˜ç§€çš„å¹¶å‘æ€§èƒ½
- **CASä¼˜åŒ–**: æ— é”ç®—æ³•æå‡æ€§èƒ½
- **çº¢é»‘æ ‘ä¼˜åŒ–**: è§£å†³å“ˆå¸Œå†²çªï¼Œä¿è¯æ€§èƒ½ç¨³å®šæ€§
- **volatileè¯­ä¹‰**: ä¿è¯å†…å­˜å¯è§æ€§

### é€‚ç”¨åœºæ™¯
- **å•JVMç¯å¢ƒ**: è¿›ç¨‹å†…æœåŠ¡æ³¨å†Œä¸å‘ç°
- **é«˜å¹¶å‘è¯»å–**: æœåŠ¡æŸ¥æ‰¾é¢‘ç¹çš„åœºæ™¯
- **åŠ¨æ€æœåŠ¡**: æ”¯æŒè¿è¡Œæ—¶æœåŠ¡æ³¨å†Œ/æ³¨é”€
- **å¼€å‘æµ‹è¯•**: ç®€åŒ–å¼€å‘å’Œæµ‹è¯•ç¯å¢ƒ

### å±€é™æ€§ä¸æ‰©å±•
- **å•æœºé™åˆ¶**: ä»…æ”¯æŒå•JVMå†…æœåŠ¡æ³¨å†Œ
- **æ— æŒä¹…åŒ–**: è¿›ç¨‹é‡å¯åæ³¨å†Œä¿¡æ¯ä¸¢å¤±
- **æ‰©å±•æ–¹å‘**: å¯ä½œä¸ºåˆ†å¸ƒå¼æ³¨å†Œä¸­å¿ƒçš„æœ¬åœ°ç¼“å­˜

é€šè¿‡æ·±å…¥åˆ†æConcurrentHashMapçš„å®ç°åŸç†å’Œæ€§èƒ½ç‰¹å¾ï¼Œæˆ‘ä»¬ä¸ä»…å®ç°äº†é«˜æ•ˆçš„æœ¬åœ°æœåŠ¡æ³¨å†Œå™¨ï¼Œä¹Ÿä¸ºç†è§£åˆ†å¸ƒå¼æ³¨å†Œä¸­å¿ƒçš„è®¾è®¡å¥ å®šäº†åŸºç¡€ã€‚è¿™ç§è®¾è®¡æ—¢æ»¡è¶³äº†å½“å‰çš„åŠŸèƒ½éœ€æ±‚ï¼Œä¹Ÿä¸ºæœªæ¥çš„æ¶æ„æ¼”è¿›æä¾›äº†è‰¯å¥½çš„æ‰©å±•æ€§ã€‚